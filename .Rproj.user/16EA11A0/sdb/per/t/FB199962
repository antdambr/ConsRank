{
    "contents" : "#          library('gregmisc')\n#          library('MASS')\n#\n\n#FAST BRANCH AND BOUND ALGORITHM BY AMODIO, D'AMBROSIO AND SICILIANO (2014)\n#Find multiple solutions for the consensus ranking problem.\n\n#CR=FASTcons(X,Wk)\n#X is a ranking data matrix (IMPORTANT: IT MUST BE A MATRIX N(JUDGES) X M(OBJECTS)\n#Wk is a vector of weights\n#CR$cons = Consensus Ranking\n#CR$Tau = TauX rank correlation coefficient\n#the code works under the dependencies of:\n#\n#          library('gregmisc')\n#          library('MASS')\n#          library('proxy')\n#\n#\n\n#This code recall the following ocdes:\n#BBconsensus.r      : principal code\n#findconsensus.r    : first approximate solution\n#kemenyd.r          : kemeny distance\n#PenaltyBB2.r       : searching for penalties\n#kemenydesign.r     : design matrix to compute kemeny distance\n#combimpmatr.r      : combined input matrix\n#scorematrix.r      : score matrix\n#ReorderingBB.r     : particular reordering necessity\n\n\n\n\nFASTcons = function(X, Wk=NULL, maxiter=50)   {\n\n  if (class(X)==\"data.frame\") {\n    #colnames(X)=NULL\n    X=as.matrix(X)\n  }\n\nM = nrow(X)\nN=ncol(X)\n\ntic = proc.time()[3]\nif (M==1) {\n  CR = X\n  Taux = 1\n  } else {\n  if (!is.null(Wk)) {\n    \n    if (is.numeric(Wk)) {\n      Wk=matrix(Wk,ncol=1)\n    }\n    \n    cij = combinpmatr(X,Wk)\n    } else {\n    cij = combinpmatr(X)\n  }\n\n\n\n  CR=matrix(0,maxiter,ncol(X))\n  for (iter in 1:maxiter) {\n\n    if (iter%%2==0) {\n        R=matrix(sample(1:ncol(X),rep=T),1,ncol(X))\n       } else {\n       R=matrix(sample(1:ncol(X)),1,ncol(X))\n       }\n\n  consensus1 = BBconsensus(R,cij)\n  cons=matrix(consensus1$cons,1,ncol(X))\n  consensus = BBconsensus(cons,cij)\n  #print(cons)\n  #print(R)\n  #flush.console()\n  CR[iter,]=matrix(consensus$cons,1,ncol(X))\n\n  }\n}\n#d=kemenyd(X,consensus$cons)\n\nTaux=matrix(0,nrow(CR),1)\nfor (k in 1:nrow(CR)) {\n  Sij=scorematrix(matrix(CR[k,],1,ncol(X)))\n  if (!is.null(Wk)){\n      Taux[k,]=sum(cij*Sij) / ( sum(Wk)* (N*(N-1)) )\n     } else {\n      Taux[k,]=sum(cij*Sij) / (  M*(N*(N-1)) )\n      }\n     }\n\nCR=reordering(CR)\nindice=which(Taux==max(Taux));\nTaux=max(Taux)\nCR=matrix(CR[indice,],ncol=N)\nif (nrow(CR>1)){\n  CR=unique(CR)\n}\nif (!is.null(dim(CR))) {\n    Taux=matrix(rep(Taux,nrow(CR)))\n    }\n\n colnames(CR)=colnames(X) \n toc = proc.time()[3]\n eltime=toc-tic\n return(list(Consensus=CR, Tau=Taux, Eltime=eltime) )\n}\n\n#-------------------------------------------------------------------------------\n\n#QUICK BRANCH AND BOUND ALGORITHM BY AMODIO, D'AMBROSIO AND SICILIANO\n#Find a solution (or a solution really close to the final one). This\n#program allows to find up to 4 multiple consensus rankings.\n\n#CR=QuickCons(X,Wk)\n#X is a ranking data matrix (IMPORTANT: IT MUST BE A MATRIX N(JUDGES) X M(OBJECTS)\n#Wk is a vector of weights\n#CR$cons = Consensus Ranking\n#CR$Tau = TauX rank correlation coefficient\n\n\n#This code recall the following ocdes:\n#BBconsensus.r      : principal code\n#findconsensus.r    : first approximate solution\n#kemenyd.r          : kemeny distance\n#PenaltyBB2.r       : searching for penalties\n#kemenydesign.r     : design matrix to compute kemeny distance\n#combimpmatr.r      : combined input matrix\n#scorematrix.r      : score matrix\n#ReorderingBB.r     : particular reordering necessity\n\n#the code works under the dependencies of:\n#\n#          library('gregmisc')\n#          library('MASS')\n#          library('proxy')\n#\n#\n\nQuickCons = function(X,Wk=NULL)   {\n\n\nif (class(X)==\"data.frame\") {\n    #colnames(X)=NULL\n    X=as.matrix(X)\n}\n\nM = nrow(X)\nN=ncol(X)\ntic = proc.time()[3]\n\nif (M==1) {\n  consensus = X\n  TauX = 1\n  } else {\n  if (!is.null(Wk)) {\n    \n    if (is.numeric(Wk)) {\n      Wk=matrix(Wk,ncol=1)\n    }\n    \n    cij = combinpmatr(X,Wk)\n    } else {\n    cij = combinpmatr(X)\n  }\n\n  R=findconsensusBB(cij)\n  R1=(N+1)-R\n  consensusA = BBconsensus(R,cij)$cons\n  consensusB = BBconsensus(consensusA,cij)$cons\n  consensusC = BBconsensus(R1,cij)$cons\n  consensusD = BBconsensus(consensusC,cij)$cons\n  consensus = unique(reordering(rbind(consensusA,consensusB,consensusC,consensusD)))\n  howcons = nrow(consensus)\n\n\n  }\n#d=kemenyd(X,consensus$cons)\n\nTaux=matrix(0,nrow(consensus),1)\nfor (k in 1:nrow(consensus)) {\n\n  #Sij=scorematrix(t(as.matrix(consensus[k,])))\n  Sij=scorematrix(matrix(consensus[k,],1,N))\n\n  if (!is.null(Wk)){\n    Taux[k,1]=sum(cij*Sij) / ( sum(Wk)* (N*(N-1)) )\n    } else {\n    Taux[k,1]=sum(cij*Sij) / (  M*(N*(N-1)) )\n    }\n\n  }\n\nif (howcons>1) {\n  nco=which(Taux==max(Taux))\n  if (length(nco)>1) {\n    consensus=consensus[nco,]\n    Taux=matrix(rep(max(Taux),nrow(consensus)),nrow(consensus),1)\n    } else {\n    Taux=max(Taux)\n    #consensus = t(matrix(consensus[nco,]))\n    consensus = matrix(consensus[nco,],1,N)\n    }\n   }\ncolnames(consensus)=colnames(X) \n toc = proc.time()[3]\n eltime=toc-tic\n return(list(Consensus=reordering(consensus), Tau=Taux, Eltime=eltime) )\n}\n\n#-------------------------------------------------------------------------------\n\n\nEMCons = function(X,Wk=NULL,PS=TRUE)  {\n#Emond and Mason Branch and Bound algorithm to find median ranking\n#X is a data matrix in which the rows are the judges and the columns indicates the objects\n#Wk is the vector of weigths\nif (class(X)==\"data.frame\") {\n    #colnames(X)=NULL\n    X=as.matrix(X)\n}\n\n\n\nM = nrow(X)\nN=ncol(X)\ntic = proc.time()[3]\nif (M==1) {\n  consensus = X\n  TauX = 1\n  } else {\n  if (!is.null(Wk)) {\n    \n    if (is.numeric(Wk)) {\n      Wk=matrix(Wk,ncol=1)\n    }\n    \n    cij = combinpmatr(X,Wk)\n    } else {\n    cij = combinpmatr(X)\n  }\n  R=findconsensusBB(cij)\n  cons1=BBconsensus(R,cij)\n  consensus1=cons1$cons\n  Po=cons1$pen\n  consensus=BBconsensus2(consensus1,cij,Po,PS)\n  }\n\n\nif (nrow(consensus)==1) {\n\n    Sij=scorematrix(consensus)\n\n        if (!is.null(Wk)){\n        TauX=sum(cij*Sij) / ( sum(Wk)* (N*(N-1)) )\n        } else {\n        TauX=sum(cij*Sij) / (  M*(N*(N-1)) )\n        }\n\n} else {\n\n    TauX=matrix(0,nrow(consensus),1)\n\n    for (k in 1:nrow(consensus)) {\n\n        Sij=scorematrix(t(matrix(consensus[k,])))\n\n        if (!is.null(Wk)) {\n\n            TauX[k,1] = sum(cij*Sij) / ( sum(Wk)*(N*(N-1)) )\n\n        } else {\n\n            TauX[k,1] = sum(cij*Sij) / (M*(N*(N-1)))\n\n        }\n\n    }\n\n}\ntoc = proc.time()[3]\ncolnames(consensus)=colnames(X) \n#consensus=reordering(consensus)\neltime=toc-tic\nreturn(list(Consensus=reordering(consensus), Tau=TauX, Eltime=eltime) )\n}\n\n\n\n\n\n#-------------------------------------------------------------------------------\n\n### COMBINED INPUT MATRIX as defined by Emond and Mason\n\n\ncombinpmatr = function (X,Wk=NULL) {\nif (is.null(Wk)) {\n#X must be data matrix with n judges (on the rows) ranking m objects (on the columns)\n  CI=matrix(0,ncol(X), ncol(X))\n  for (i in 1:nrow(X)){\n    sm=scorematrix(t(as.matrix(X[i,])))\n    CI=CI+sm\n  }\n  } else {\n    \n    if (is.numeric(Wk)) {\n      Wk=matrix(Wk,ncol=1)\n    }\n    \n  CI=matrix(0,ncol(X), ncol(X))\n  for (i in 1:nrow(X)){\n    sm=scorematrix(t(as.matrix(X[i,])))*Wk[i]\n    CI=CI+sm\n  }\n  }\nCI\n}\n\n#-------------------------------------------------------------------------------\n\nBBconsensus = function(RR,cij) {\n\n#Branch and Bound Algorithm to find the the consensus ranking PART I As modified by D'AMBROSIO (2008).\n#Find the first approximation to the consensus ranking. Most of the time CR\n#is a solution, maybe not unique\n#Input:\n#       RR -> First solution candidate to be the consensus ranking\n#       cij -> Combined Input Matrix of the M individuals which judge n\n#       objects\n#Output:\n#       CR -> Consensus Ranking\n#\n#\n#References: Emond and Mason, 2002.\n\n\nCR=RR;\nsij=scorematrix(RR);\n#Po=sum(sum(abs(cij)))-sum(sum(cij.*sij));\nPo = sum(abs(cij))-sum(cij*sij)\na = t(matrix(sort(RR,decreasing = TRUE)))\nord = t(matrix(order(RR,decreasing = TRUE)))\nR=RR;\naddpenalty=matrix(0,length(a),1)\n\n# exploration of the initial solution\nfor (k in 2:length(a)) {\n  #print(k)\n  b = 1:k\n  R = ReorderingBB(R)\n  KR=t(matrix(R[ord[b]]))\n  KR=KR[-length(KR)]\n  MO=max(KR)\n  MI=min(KR)\n  aa=1\n  KO=1\n  KR[length(KR)+1]=MO+1;\n  R[ord[b]]=KR\n  candidate=matrix(0,nrow(RR), ncol(RR))\n  Pb = matrix(0, 1, 1)\n  while (KO==1)  {\n    #browser()\n    candidate=rbind(candidate,R)\n    #if (ncol(candidate>ncol(RR))) {\n\n    #print(dim(candidate))\n    #print(dim(R))\n    #print(class(candidate))\n    #print(class(R))\n\n   # }\n    if (aa==1){\n      candidate=matrix(candidate[-1,],1,ncol(candidate))\n      }\n\n    Sij=scorematrix(matrix(candidate[aa,],1,ncol(R)))\n  # print(Sij)\n   #print(candidate)\n   #flush.console()\n    Pb=rbind(Pb,sum(abs(cij))-sum(cij*Sij))\n    if (aa==1) {\n      Pb=matrix(Pb[-1,],1,1)\n    }\n   # print(Pb)\n    if (Pb[aa]==0) {\n\n      CR = R\n      Po = 0\n      Pc = 0\n      break\n      }\n      Pc=1\n    R[ord[b[length(b)]]] = R[ord[b[length(b)]]]-1\n    if (MI-R[ord[b[length(b)]]] > 1) {\n      KO = 0\n      }\n    aa=aa+1\n    }\n\n    if (Pc == 0) {\n      break\n      }\n\n   minp=min(Pb)\n   posp=which(Pb==min(Pb))\n\n   if (minp<=Po) {\n    Po=minp\n    CR=t(matrix(candidate[posp[1],]))\n    R=CR\n    addpenalty[k,1]=PenaltyBB2(cij,R,ord[b])\n    } else {\n    R = CR\n    addpenalty[k,1]=PenaltyBB2(cij,R,ord[b])\n    }\n\n    candidate = mat.or.vec(nrow(R), ncol(R))\n    Pb = mat.or.vec(1, 1)\n\n    }\n\nif (Pc==0) {\n  Po=0\n  addpenalty = 0\n  }\n  else {\n  Poo=sum(addpenalty)\n  }\n\n  SIJ = scorematrix(CR)\n  Po=sum(addpenalty)\n\nreturn(list(cons=CR,pen=Po))\n}\n\n#-------------------------------------------------------------------------------\n\n## Place labels in a data matrix X of rankings (N judges by M objects)\n#m is the number of objects\n#label (optional) is the vector of the objects names\n#labs = 1 or 2\n\nlabels = function(x, m, label = 1:m, labs ){\n#source('reordering.r')\n# if the class of the object is different from 'matrix' transform it in 'matrix'\n  if(class(x) != 'matrix'){\n  obs = length(x)\n  XX = matrix(x, ncol = obs)\n  } else {\n  XX = x\n  }\n\nnj = nrow(XX)\nnob = ncol(XX)\n\n# if length of the object is higher than m, last number is the penalty\nif(nob > m){\n# if the number of rows is 1 is a vector\n  if(nj == 1){\n    pens = x[m+1]\n    X = matrix(reord(XX[1:m], m), ncol = m)\n    } else {\n    pens = x[,m+1]\n    X = t(apply(x, 1, function(g) reord(g, m)))\n    }\n} else {\nX = XX\n}\nif(labs ==1){\nlet = label\n} else if(labs == 2){\nlet = LETTERS[label]\n}\n\nout = rep(0, nj)\nfor(i in 1:nj){\n\nord = rank(X[i,])\norders = tapply(let, ord, sort)\n\nnames1 = NULL\nfor(j in 1:length(orders)){\nif(length(orders[[j]]) > 1){\nnams = paste('(', paste(orders[[j]], sep = '', collapse = ''), ')', sep = '', collapse='')\n} else {\nnams = paste(orders[[j]], collapse = '')\n}\nnames1 = c(names1, nams)\n}\nout[i] = paste(names1, collapse = ' ' )\n}\nout = matrix(out, nrow = nj)\n\nif(nob > m){\ndat = data.frame(data = out, pens = pens)\n} else {\ndat = out\n}\n\nreturn(dat)\n}\n\n#-------------------------------------------------------------------------------\n\n### SCORE MATRIX OF RANK DATA ACCORDING EMOND AND MASON\n\n\nscorematrix = function (X) {\n  \nif (is.numeric(X) & !is.matrix(X)){\n  X=matrix(X,ncol=length(X))\n}\n  \n#X must be a row vector containing a ranking of m objects\nsm=matrix(0,ncol(X), ncol(X))\nindex=combinations(ncol(X),2)\nfor (i in 1:nrow(index)){\n  if (!is.na(X[index[i,1]]) && !is.na(X[index[i,2]]) ) {\n    if (X[index[i,1]]>X[index[i,2]]) {    #if object i is prerferred to object j\n        sm[index[i,1],index[i,2]] = -1\n        sm[index[i,2],index[i,1]] = 1\n        } else if (X[index[i,1]]<X[index[i,2]]) {  #if object i is not prerferred to object j\n        sm[index[i,1],index[i,2]] = 1\n        sm[index[i,2],index[i,1]] = -1\n        } else if (X[index[i,1]] == X[index[i,2]]) {  #if object i is in a tie with object j\n        sm[index[i,1],index[i,2]] = 1\n        sm[index[i,2],index[i,1]] = 1\n     }\n     }\n     else {\n     sm[index[i,1],index[i,2]] = 0\n     sm[index[i,2],index[i,1]] = 0\n     }\n}\nsm\n}\n\n#-------------------------------------------------------------------------------\n\ntabulaterows = function(X,miss=FALSE) {\n      \n#given a sample of preference rankings, it counts the judges that have equal preferences\n#and it tabulates the row of the data matrix\n            \nif (sum(is.na(X))>0) {\n  miss=TRUE\n  X[is.na(X)]=-10\n}\n            \ncoun = table(apply(X, 1, paste, collapse=\",\"))\nnam = names(coun)\nspl = (strsplit(nam, \",\"))\nkkn  = lapply(spl, as.numeric)\ntab = t(as.data.frame(kkn))\ncek =  cbind(tab,coun)\ncoun=as.matrix(coun)\nrownames(coun)=NULL\nrownames(tab)=NULL\nif (miss==TRUE) {\n  tab[tab==-10]=NA\n}\n      \n          \nreturn(list(X=tab, Wk=coun, tabfreq=cbind(tab,coun)))\n}\n          \n          \n\n\n#-------------------------------------------------------------------------------\n\nbranches = function(brR,cij,b,Po,ord,Pb) {\n\ncandidate = findbranches(brR,ord,b)\nPb =matrix( rep(Pb,nrow(candidate)))\n\nCR=mat.or.vec(nrow(candidate),ncol(candidate))\naddpenalty=matrix(0,nrow(candidate),1)\nQR=mat.or.vec(nrow(candidate),ncol(candidate))\n\nfor (gm in 1:nrow(candidate)) {\n\n    CR[gm,]=candidate[gm,]\n    addpenalty[gm,]=PenaltyBB2(cij,candidate[gm,],ord[b])\n\n    if (Pb[gm]+addpenalty[gm] > Po) {\n\n        CR[gm,]=-10.0e+15\n        addpenalty[gm]=-10.0e+15\n\n        }\n    QR[gm,]=CR[gm,]\n    }\nPbr=addpenalty+Pb\nidp=Pbr<0\n\nif (sum(idp)==0) {\n\n    R=QR\n\n    } else if (sum(idp==F)==nrow(QR)) {\n\n    Pbr=NULL\n    Pb=NULL\n    R=NULL\n\n    } else {\n    Pbr=t(matrix(Pbr[idp==FALSE,],1))\n    if (sum(idp==F)==1) {\n        R=t(matrix(QR[idp==FALSE,]))\n        } else {\n        R=QR[idp==FALSE,]\n        }\n    }\n\nreturn(list(cR=R,pcR=Pbr))\n}\n\n#-------------------------------------------------------------------------------\n\n# given a ranking multiplied by 2, it returns a \"normal\" ranking\nreordering = function (X) {\n\nif (nrow(X)==1) {\n    G=X\n    OX = order(X)\n    SX=matrix(sort(X),nrow=1)\n    SX=SX-min(SX)+1\n    DC=rbind(0,diff(t(SX)))\n\n\n    for (i in 1:(ncol(X)-1)) {\n        if (DC[i+1,1] >= 1) {\n          SX[1,i+1]=SX[1,i]+1\n          } else if (DC[i+1,1] == 0) {\n          SX[1,i+1]=SX[1,i]\n          }\n      }\n\n    G[1,OX]=SX\n\n    } else {\n\n    G=X\n    for (j in 1:nrow(X)) {\n\n        OX = order(X[j,])\n        SX=matrix(sort(X[j,]),nrow=1)\n        SX=SX-min(SX)+1\n        DC=rbind(0,diff(t(SX)))\n\n        for (i in 1:(ncol(X)-1)) {\n\n            if (DC[i+1,1] >= 1) {\n            SX[1,i+1]=SX[1,i]+1\n            } else if (DC[i+1,1] == 0) {\n            SX[1,i+1]=SX[1,i]\n            }\n        }\n    G[j,OX]=SX\n  }\n\n }\n\nG\n}\n\n#-------------------------------------------------------------------------------\n\nfindbranches = function(R,ord,b) {\n\n  KR=t(matrix(R[ord[b]]))\n  KR=KR[-length(KR)]\n  MO=max(KR)\n  MI=min(KR)\n  aa=1\n  KO=1\n  KR[length(KR)+1]=MO+1;\n  R[ord[b]]=KR\n  candidate=mat.or.vec(nrow(R), ncol(R))\n\n  while (KO==1)  {\n      candidate=rbind(candidate,R)\n\n      if (aa==1){\n          candidate=matrix(candidate[-1,],1,ncol(candidate))\n      }\n      R[ord[b[length(b)]]]=R[ord[b[length(b)]]]-1\n\n      if (MI-R[ord[b[length(b)]]] > 1) {\n\n          KO=0\n\n      }\n\n      aa=aa+1\n\n  }\n\n  Rt=candidate\n\n}\n\n#-------------------------------------------------------------------------------\n\n## DETERMINATION OF PENALTIES FOR THE BRANCH AND BOUND ALGORITHM\n\nPenaltyBB2 = function(cij,candidate,ord)   #indice must be order(CR)\n{\n\nDs=t(mat.or.vec(1,(length(ord)-1)));\naddpenalty=t(mat.or.vec(1,(length(ord)-1)));\n\nfor (k in 1:(length(ord)-1)) {\n\n  Ds[k,1]=sign(candidate[ord[length(ord)]]-candidate[ord[k]]);\n\n  if (Ds[k,1]==1) {\n\n\n    if ( sign(cij[ord[length(ord)],ord[k]]) == 1 & sign(cij[ord[k],ord[length(ord)]])  == -1 ) {\n       addpenalty[k,1]=cij[ord[length(ord)],ord[k]]-cij[ord[k],ord[length(ord)]]\n      } else if ( sign(cij[ord[length(ord)],ord[k]]) == 1 & sign(cij[ord[k],ord[length(ord)]]) == 1  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 0 & sign(cij[ord[k],ord[length(ord)]]) == 0  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 1 & sign(cij[ord[k],ord[length(ord)]]) == 0  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 0 & sign(cij[ord[k],ord[length(ord)]]) == 1) {\n      addpenalty[k,1]=cij[ord[length(ord)],ord[k]]\n      } else if ( sign(cij[ord[length(ord)],ord[k]]) == -1 & sign(cij[ord[k],ord[length(ord)]]) == 1) {\n      addpenalty[k,1]=0\n      }\n    }\n  else if (Ds[k,1]==-1) {\n      if ( sign(cij[ord[length(ord)],ord[k]]) == 1 && sign(cij[ord[k],ord[length(ord)]])  == -1 ) {\n       addpenalty[k,1]=0\n      } else if ( sign(cij[ord[length(ord)],ord[k]]) == 1 && sign(cij[ord[k],ord[length(ord)]]) == 1  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 0 && sign(cij[ord[k],ord[length(ord)]]) == 0  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 1 && sign(cij[ord[k],ord[length(ord)]]) == 0  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 0 && sign(cij[ord[k],ord[length(ord)]]) == 1) {\n      addpenalty[k,1]=cij[ord[k],ord[length(ord)]]\n      } else if ( sign(cij[ord[length(ord)],ord[k]]) == -1 && sign(cij[ord[k],ord[length(ord)]]) == 1) {\n      addpenalty[k,1]=cij[ord[k],ord[length(ord)]]-cij[ord[length(ord)],ord[k]]\n      }\n  }\n\n else if (Ds[k,1]==0) {\n       if ( sign(cij[ord[length(ord)],ord[k]]) == 1 && sign(cij[ord[k],ord[length(ord)]])  == -1 ) {\n       addpenalty[k,1]=-cij[ord[k],ord[length(ord)]]\n      } else if ( sign(cij[ord[length(ord)],ord[k]]) == 1 && sign(cij[ord[k],ord[length(ord)]]) == 1  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 0 && sign(cij[ord[k],ord[length(ord)]]) == 0  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 1 && sign(cij[ord[k],ord[length(ord)]]) == 0  ||\n                  sign(cij[ord[length(ord)],ord[k]]) == 0 && sign(cij[ord[k],ord[length(ord)]]) == 1) {\n      addpenalty[k,1]=0\n      } else if ( sign(cij[ord[length(ord)],ord[k]]) == -1 && sign(cij[ord[k],ord[length(ord)]]) == 1) {\n      addpenalty[k,1]=-cij[ord[length(ord)],ord[k]]\n      }\n }\n}\n\naddpenalty=sum(addpenalty)\n\n}\n\n#-------------------------------------------------------------------------------\n\nfindconsensusBB = function(cij) {\n\nX=mat.or.vec(1,ncol(cij)) + 1\nN=ncol(X)\nindici=combinations(N,2)\nfor (j in 1:nrow(indici)) {\n  if ( sign(cij[indici[j,1],indici[j,2]]) == 1 & sign(cij[indici[j,2],indici[j,1]]) == -1 ) {\n    X[indici[j,1]]=X[indici[j,1]]+1\n    } else if ( sign(cij[indici[j,1],indici[j,2]]) == -1 & sign(cij[indici[j,2],indici[j,1]]) == 1 ) {\n    X[indici[j,2]]=X[indici[j,2]] + 1\n    } else if (sign(cij[indici[j,1],indici[j,2]]) == -1 & sign(cij[indici[j,2],indici[j,1]]) == -1 ) {\n    X[indici[j,1]]= NA\n    }\n  }\n\nreturn(X)\n}\n\n#-------------------------------------------------------------------------------\n\n#Compute the design matrix to compute Kemeny distance\nkemenydesign = function(X) {\n  \n  if (is.numeric(X) & !is.matrix(X)) {\n    X=matrix(X,ncol=length(X))\n  }\n  \n  \n  \nM = ncol(X)\nN = nrow(X)\nindice=combinations(M,2)\nKX=mat.or.vec(N,(M*(M-1)/2) )\nfor (j in 1:nrow(indice)) {\n  KX[,j]=sign(X[,indice[j,1]] - X[,indice[j,2]])*-1\n  }\n KX\n}\n\n#-------------------------------------------------------------------------------\n\n##Kemeny Distance\nkemenyd = function(X,Y=NULL) {\n  \n  if (is.numeric(X) & !is.matrix(X)) {\n    X=matrix(X,ncol=length(X))\n  }\n  \nif (is.null(Y)) {\n  X = kemenydesign(X)\n  d=dist(X,\"manhattan\")\n  } else {\n    \n    if (is.numeric(Y) & !is.matrix(Y)) {\n      Y=matrix(Y,ncol=length(Y))\n    }\n\n    \n  X=kemenydesign(X)\n  Y=kemenydesign(Y)\n  d=dist(X,Y,\"manhattan\")\n }\nd\n}\n\n#-------------------------------------------------------------------------------\n\nReorderingBB = function(RR) {\n\nRR = RR+1\nR = RR;\nk = ncol(R)\nneword = order(R)\nindexing = mat.or.vec(1, ncol(R)-1)\nfor (j in (k-1):1) {\n  indexing[j] = R[neword[j+1]]-R[neword[j]]\n  }\n\nif (sum(indexing==0)>0) {\n  J = 1\n  while (J<=ncol(indexing)) {\n    if (indexing[J]==0) {\n      R[neword[J+1]]=R[neword[J]]\n      J=J+1\n      }\n      else if (indexing[J]>0) {\n      R[neword[J+1]] = R[neword[J]]+2\n      J=J+1\n      }\n    }\n   }\n  else  {\n    J = 1\n    while (J<= ncol(indexing)) {\n      R[neword[J+1]] = R[neword[J]] + 2\n      J=J+1\n      }\n    }\n    R\n  }\n  \n  #-------------------------------------------------------------------------------\n\n  ## DETERMINATION OF PENALTIES FOR THE BRANCH AND BOUND ALGORITHM\n\nPenalty = function(CR,cij,indice)   #indice must be order(CR)\n{\n  if (CR[indice[1,1]] < CR[indice[1,2]]) { #case 1, the first object is preferred\n                                          #to the second object\n     if (sign(cij[indice[1,1],indice[1,2]]) == 1 & sign (cij[indice[1,2],indice[1,1]]) == -1) {\n     Po=0\n     } else if (sign(cij[indice[1,1],indice[1,2]]) == -1 & sign (cij[indice[1,2],indice[1,1]]) == 1) {\n     Po = cij[indice[1,2],indice[1,1]]-cij[indice[1,1],indice[1,2]]  #     cji-cij\n     } else if (sign(cij[indice[1,1],indice[1,2]]) == 1 & sign (cij[indice[1,2],indice[1,1]]) == 1) {\n     Po = cij[indice[1,2],indice[1,1]] #cji\n     }\n  } else if (CR[indice[1,1]] > CR[indice[1,2]]) { #case 2 the first object is not\n                                                      #preferred to the second one\n     if (sign(cij[indice[1,1],indice[1,2]]) == 1 & sign (cij[indice[1,2],indice[1,1]]) == -1) {\n     Po= cij[indice[1,1],indice[1,2]]-cij[indice[1,2],indice[1,1]]  #cij-cji\n     } else if (sign(cij[indice[1,1],indice[1,2]]) == -1 & sign (cij[indice[1,2],indice[1,1]]) == 1) {\n     Po = 0\n     } else if (sign(cij[indice[1,1],indice[1,2]]) == 1 & sign (cij[indice[1,2],indice[1,1]]) == 1) {\n     Po = cij[indice[1,1],indice[1,2]] #cij\n     }\n  } else if (CR[indice[1,1]] == CR[indice[1,2]]) { #case 3 they are in a tie\n     if (sign(cij[indice[1,1],indice[1,2]]) == 1 & sign (cij[indice[1,2],indice[1,1]]) == -1) {\n     Po = -cij[indice[1,2],indice[1,1]] #-cj\n     } else if (sign(cij[indice[1,1],indice[1,2]]) == -1 & sign (cij[indice[1,2],indice[1,1]]) == 1) {\n     Po = -cij[indice[1,1],indice[1,2]] #-cij\n     } else if (sign(cij[indice[1,1],indice[1,2]]) == 1 & sign (cij[indice[1,2],indice[1,1]]) == 1 |\n     sign(cij[indice[1,1],indice[1,2]]) == 0 & sign (cij[indice[1,2],indice[1,1]]) == 0 )  {\n     Po = 0\n     }\n\n  }\n  Po\n }\n          \n#---------------------------------------------------------------------------------\n##Core code for the computation of the consensus ranking. Branch-and-bound \n##algorithm by Emond and Mason\n          \nBBconsensus2 = function(RR,cij,Po,PS=TRUE) {\n#Core function in computing consensus ranking\nCR=RR;\na = t(matrix(sort(RR)))\nord = t(matrix(order(RR)))\nr=ReorderingBB(RR)\nBR.R=r #initialize ranking\nBR.P=0 #initialize penalty\nWCi=1\nlambda=1\nnobj=ncol(RR)\nwhile (WCi == 1){\n  if (PS==TRUE) {\n      dsp1=paste(\"round\",lambda,sep=\" \")\n      print(dsp1) \n    }\n              \n for (k in 2:ncol(a)) { #primary loop: add the k^th better object ranked\n                \n    B = nrow(BR.R)    #branches size\n    if (PS==TRUE) {\n          \n      dsp2=paste(\"evaluating\",B,\"branches\",sep=\" \")\n      print(dsp2)\n                  \n    }\n                #print(B)\n                #flush.console()\n                \n    b=1:k\n          \n                \n    for (nb in 1:B) { #Secondary loop:  check the branches created by \"nb\"\n                   \n      BR.R[nb,] = ReorderingBB(t(matrix(BR.R[nb,])))\n      rpbr=branches(matrix(BR.R[nb,],1,),cij,b,Po,ord,matrix(BR.P[nb]))\n      R=rpbr$cR\n      Pbr=rpbr$pcR        \n              \n                  \n      if (is.null(R)) {\n                  \n                    #if (nb==1) {\n                    #\n                    #    JR=0\n                    #    \n                    #    next\n                    #    \n                    #} else {     \n                    \n        next\n                    \n                    #}\n        } else {         #process good rankings\n                    \n        if (nb==1) {     #starting point\n                      \n                      #JR=nrow(R)\n                      \n            KR.R=R\n            KR.P=Pbr\n              \n                      \n                      \n            } else {   #it is not the starting point\n                      \n            KR.R=rbind(KR.R,R)\n            KR.P=rbind(KR.P,Pbr)\n                  \n                      \n        }\n                    \n     }\n                  \n                  #JR = nrow(KR.R)  #update size of branches\n                  \n    } #end secondary loop\n                \n    if (is.null(R)) {\n                  \n      if (nb==B & nb!=1) { #If at the last iteration of the secondary loop all of thye rankings are not good \n                    \n          rm(BR.R) #BR.R = NULL    #rm(BR.R)\n          rm(BR.P) #BR.P = NULL    #rm(BR.P)\n          BR.R = KR.R\n          BR.P = KR.P\n          KR.R = NULL\n          KR.P = NULL\n          #rm(JR) #JR = NULL\n                    \n          } else {\n                    \n          next\n                    \n      }\n                  \n    } else {\n                  \n    rm(BR.R) #BR.R = NULL  #rm(BR.R)\n    rm(BR.P) #BR.P = NULL  #rm(BR.P)\n    BR.R = KR.R\n    BR.P = matrix(KR.P)\n    #KR.R = NULL\n    #KR.P = NULL\n    #rm(JR)  #JR = NULL\n                \n  }\n                \n } #end primary loop\n              \n              #AccPen = BR.P\n              \n              \n SSP=matrix(which(BR.P==min(BR.P)))\n MinP=min(BR.P)\n PenMin=Po-MinP\n              \n if (PenMin==0) {\n                \n    #CR=t(matrix(BR.R[SSP,]))\n   CR=matrix(BR.R[SSP,],length(SSP),nobj)\n   WCi = 0\n                \n   } else {\n                \n   Po=MinP\n   WCi=1\n   lambda=lambda+1\n   #nRR=t(matrix((BR.R[SSP[1],])))\n   nRR=matrix((BR.R[SSP[1],]),1,nobj)\n   rm(BR.R)\n   rm(BR.P)\n   BR.R=nRR\n   BR.P=0\n   a = t(matrix(sort(BR.R)))\n   ord = t(matrix(order(BR.R)))\n   rm(nRR)\n                \n  }\n              \n }   #end while\n            \n            CR\n}\n\n#-------------------------------------------------------------\nTau_X = function(X,Y=NULL) {\n  \n  if(is.numeric(X) & !is.matrix(X)){\n    X=matrix(X,ncol=length(X))\n  }\n  \n  \n  N=ncol(X)\n  maxd=N*(N-1)\n  if (is.null(Y)){\n    d=kemenyd(X)\n    tau = 1-(2*d/maxd)\n  } else {\n    if(is.numeric(Y) & !is.matrix(Y)){\n      Y=matrix(Y,ncol=length(Y))\n    }\n    d=kemenyd(X,Y)\n    tau = 1-(2*d/maxd)\n  }\n tau \n}\n  \n#------------------------------------------------------------------------\npolyplot = function(X=NULL,L=NULL,Wk=NULL,nobj=3){\n\n  \n  if (nobj==3){\n    \n    #rankings in the polytope\n    ranks=rbind(\n      c(1,2,3),\n      c(1,2,2),\n      c(1,3,2),\n      c(1,2,1),\n      c(2,3,1),\n      c(2,2,1),\n      c(3,2,1),\n      c(2,1,1),\n      c(3,1,2),\n      c(2,1,2),\n      c(2,1,3),\n      c(1,1,2),\n      c(1,1,1)\n    )\n    \n    if (is.null(L)){\n      rr=labels(ranks,3,labs=2)\n    } else {\n      rr=labels(ranks,3,L,labs=1)\n    }\n    \n    #coordinates of polytope\n    coord=rbind(\n      c(  0.000000e+00,  4.082483e-01), #ABC\n      c(  1.767767e-01,  3.061862e-01), #A(BC)\n      c(  3.535534e-01,  2.041241e-01), #ACB\n      c(  3.535534e-01,  1.817407e-16), #(AC)B\n      c(  3.535534e-01, -2.041241e-01), #CAB\n      c(  1.767767e-01, -3.061862e-01), #C(AB)\n      c(  5.192593e-17, -4.082483e-01), #CBA\n      c( -1.767767e-01, -3.061862e-01), #(BC)A\n      c( -3.535534e-01, -2.041241e-01), #BCA\n      c( -3.535534e-01, -1.038519e-16), #B(AC)\n      c( -3.535534e-01,  2.041241e-01), #BAC\n      c( -1.767767e-01,  3.061862e-01), #(AB)C\n      c(  5.517130e-17,  4.543519e-17)  #(ABC)\n    )\n    \n    \n    plot(coord,ylim=c(-0.5,0.5),xlim=c(-0.5,0.5),axes=FALSE,ann=FALSE)\n    lines(coord[1:11,])\n    lines(c(coord[11,1],coord[1,1]),c(coord[11,2],coord[1,2]))\n    lines(c(coord[2,1],coord[8,1]),c(coord[2,2],coord[8,2]),lty=2)\n    lines(c(coord[4,1],coord[10,1]),c(coord[4,2],coord[10,2]),lty=2)\n    lines(c(coord[6,1],coord[12,1]),c(coord[6,2],coord[12,2]),lty=2)\n    \n    t1=c(1,2,3,11,12,13)\n    t2=c(4,10)\n    t3=c(5,6,7,8,9)\n    tcoord=coord #text coordinates\n    tcoord[t1,2]=tcoord[t1,2]+0.1\n    tcoord[t3,2]=tcoord[t3,2]-0.1\n    tcoord[t2[1],1]=tcoord[t2[1],1]+0.1\n    tcoord[t2[2],1]=tcoord[t2[2],1]-0.1\n    #text(tcoord,rr)\n    \n    if (is.null(X)){\n      indplot=matrix(1:13,ncol=1)\n    } else {\n      \n      #o = outer(seq_len(nrow(X)), seq_len(nrow(ranks)), Vectorize(\n      #  function(i, j) all(X2[i,]==ranks[j,])\n      #))\n      #ranksinplot=ranks[apply(o, 2, any),]\n      \n      o2 = outer(seq_len(nrow(ranks)), seq_len(nrow(X)), Vectorize(\n        function(i, j) which(all(ranks[i,]==X[j,]))\n      ))\n      \n      indexing=o2==1\n      #print(indexing)\n      indexing[indexing==TRUE]=1\n      indexing[is.na(indexing)]=0\n      indplot=which(rowSums(indexing)==1)\n      #print(indplot)\n    }\n    \n    # if (is.null(X)){\n    #   X=ranks\n    # }\n    #X\n    #put labels to rankings\n    if (is.null(Wk)){\n      \n      points(coord[indplot,1],coord[indplot,2],pch=16,cex=0.8,col=\"blue\")\n      \n    }else{\n      \n      if (is.numeric(Wk)) {\n        \n        Wk=matrix(Wk,ncol=1)\n        \n      }\n      \n      points(coord[indplot,1],coord[indplot,2],pch=16,cex=sqrt(100*((Wk/sum(Wk))/pi)/2),col=\"blue\")\n          \n    }\n      \n    text(tcoord[indplot,],rr[indplot,])\n    \n  }else{ ##4 objects\n    \n    \n    #---------------------------------------------\n    \n    #-Exagon A first\n    E1=rbind(\n      c(0.5,  0.5,  1.4142135),  #   ...    %%'A B C D'     [1 2 3 4]   1\n      c(1.0,  1.0,  0.70710677), #  ...    %%'A C B D'     [1 3 2 4]   2\n      c(1.5,  0.5,  0.0), #                 %%'A C D B'     [1 4 2 3]   3\n      c(1.5, -0.5,  0.0), #         ...    %%'A D C B'     [1 4 3 2]   4\n      c(1.0, -1.0,  0.70710677), #  ...    %%'A D B C'     [1 3 4 2]   5\n      c(0.5, -0.5,  1.4142135) #   ...    %%'A B D C'     [1 2 4 3]   6\n    )\n    \n    \n    MA=apply(E1,2,mean) #  center of exagon A   A(BCD)  [1 2 2 2]  7\n    E1T=rbind(\n      c(1.2500,    0.7500,    0.3536),#;...  %% 'A C {BD}'   [1 3 2 3]   8\n      c(0.7500,   -0.7500,    1.0607),#;...  %% 'A {BD} C'   [1 2 3 2]   9\n      c(0.5000,         0,    1.4142),#;...  %% 'A B {CD}'   [1 2 3 3]   10\n      c(1.5000,         0,         0),#;...  %% 'A {CD} B'   [1 3 2 2]   11\n      c(1.2500,   -0.7500,    0.3536),#;...  %% 'A D {BC}'   [1 3 3 2]   12\n      c(0.7500,    0.7500,    1.0607)# ;...  %% 'A {BC} D'   [1 2 2 3]   13\n    )\n    \n    \n    \n    ranksA=rbind(\n      c(1,2,3,4),c(1,3,2,4),c(1,4,2,3),c(1,4,3,2),c(1,3,4,2),c(1,2,4,3),c(1,2,2,2),\n      c(1,3,2,3),c(1,2,3,2),c(1,2,3,3),c(1,3,2,2),c(1,3,3,2),c(1,2,2,3)\n    )\n    \n    #---------------------------------------------\n    #-Exagon B first\n    E2=rbind(\n      c(-1.5, -0.5,  0.0),#        ...    %%'B D C A'     [4 1 3 2]   14\n      c(-1.5,  0.5,  0.0),#        ...    %%'B C D A'     [4 1 2 3]   15 \n      c(-1.0,  1.0,  0.70710677),# ...    %%'B C A D'     [3 1 2 4]   16 \n      c(-0.5,  0.5,  1.4142135),#  ...    %%'B A C D'     [2 1 3 4]   17\n      c(-0.5, -0.5,  1.4142135),#  ...    %%'B A D C'     [2 1 4 3]   18\n      c(-1.0, -1.0,  0.70710677)# ...    %%'B D A C'     [3 1 4 2]   19\n    )\n    \n    MB=apply(E2,2,mean) #center of exagon B  B(ACD)        [2 1 2 2]  20\n    \n    E2T=rbind(\n      c(-0.5000,         0,    1.4142),#; ... %% 'B A {CD}'   [2 1 3 3]   21\n      c(-1.5000,         0,         0),#;...  %% 'B {CD} A'   [3 1 2 2]   22\n      c(-1.2500,    0.7500,    0.3536),#;...  %% 'B C {AD}'   [3 1 2 3]   23\n      c(-0.7500,   -0.7500,    1.0607),#;...  %% 'B {AD} C'   [2 1 3 2]   24\n      c(-1.2500,   -0.7500,    0.3536),#;...  %% 'B D {AC}'   [3 1 3 2]   25\n      c(-0.7500,    0.7500,    1.0607)# ;...  %% 'B {AC} D'   [2 1 2 3]   26\n    )\n    \n    \n    ranksB=rbind(\n      c(4,1,3,2),c(4,1,2,3),c(3,1,2,4),c(2,1,3,4),c(2,1,4,3),c(3,1,4,2),c(2,1,2,2),\n      c(2,1,3,3),c(3,1,2,2),c(3,1,2,3),c(2,1,3,2),c(3,1,3,2),c(2,1,2,3)\n    )\n    \n    \n    \n    #-------------------------------------------------\n    #exagon C first\n    \n    E3=rbind(\n      c(-1.0,  1.0, -0.70710677),# ...    %%'C B D A'     [4 2 1 3]   27\n      c(-0.5,  0.5, -1.4142135),#  ...    %%'C D B A'     [4 3 1 2]   28\n      c(0.5,  0.5, -1.4142135),#   ...    %%'C D A B'     [3 4 1 2]   29\n      c(1.0,  1.0, -0.70710677),#  ...    %%'C A D B'     [2 4 1 3]   30\n      c(0.5,  1.5,  0.0),#         ...    %%'C A B D'     [2 3 1 4]   31\n      c(-0.5,  1.5,  0.0) #        ...    %%'C B A D'     [3 2 1 4]   32\n    )\n    \n    MC=apply(E3,2,mean) #center of exagon C  C(ABD)        [2 2 1 2] 33\n    \n    E3T=rbind(\n      c(0,    0.5000,   -1.4142),      #;...  %% 'C D {AB}'   [3 3 1 2]   34\n      c(0,    1.5000,         0),      #;...  %% 'C {AB} D'   [2 2 1 3]   35\n      c(0.7500,    1.2500,   -0.3536), #;...  %% 'C A {BD}'   [2 3 1 3]   36\n      c(-0.7500,    0.7500,   -1.0607),#;...  %% 'C {BD} A'   [3 2 1 2]   37\n      c(0.7500,    0.7500,   -1.0607), #;...  %% 'C {AD} B'   [2 3 1 2]   38\n      c(-0.7500,    1.2500,   -0.3536) #;...  %% 'C B {AD}'   [3 2 1 3]   39\n    )\n    \n    ranksC=rbind(c(4,2,1,3),c(4,3,1,2),c(3,4,1,2),c(2,4,1,3),c(2,3,1,4),c(3,2,1,4),c(2,2,1,2),\n                 c(3,3,1,2),c(2,2,1,3),c(2,3,1,3),c(3,2,1,2),c(2,3,1,2),c(3,2,1,3)             \n    )\n    \n    \n    #--------------------------------------\n    #exagon D first\n    \n    E4=rbind(\n      c(-1.0, -1.0, -0.70710677),# ...    %%'D B C A'     [4 2 3 1]   40\n      c(-0.5, -0.5, -1.4142135),#  ...    %%'D C B A'     [4 3 2 1]   41\n      c(0.5, -0.5, -1.4142135),#   ...    %%'D C A B'     [3 4 2 1]   42\n      c(1.0, -1.0, -0.70710677),#  ...    %%'D A C B'     [2 4 3 1]   43\n      c(0.5, -1.5,  0.0),#         ...    %%'D A B C'     [2 3 4 1]   44\n      c(-0.5, -1.5,  0.0) #        ...    %%'D B A C'     [3 2 4 1]   45\n    )\n    \n    MD=apply(E4,2,mean) #center of exagon D  D(ABC)        [2 2 2 1]  46\n    \n    E4T=rbind(\n      c(0,   -0.5000,   -1.4142),      #;...  %% 'D C {AB}'   [3 3 2 1]   47\n      c(0,   -1.5000,         0),      #;...  %% 'D {AB} C'   [2 2 3 1]   48\n      c(-0.7500,   -1.2500,   -0.3536),#;...  %% 'D B {AC}'   [3 2 3 1]   49\n      c(0.7500,   -0.7500,   -1.0607), #;...  %% 'D {AC} B'   [2 3 2 1]   50\n      c(-0.7500,   -0.7500,   -1.0607),#;...  %% 'D {BC} A'   [3 2 2 1]   51\n      c(0.7500,   -1.2500,   -0.3536)  #;...  %% 'D A {BC}'   [2 3 3 1]   52\n    )\n    \n    ranksD=rbind(c(4,2,3,1),c(4,3,2,1),c(3,4,2,1),c(2,4,3,1),c(2,3,4,1),c(3,2,4,1),c(2,2,2,1),\n                 c(3,3,2,1),c(2,2,3,1),c(3,2,3,1),c(2,3,2,1),c(3,2,2,1),c(2,3,3,1)             \n    )\n    \n    \n    #squares----------------------------------------------------------\n    ESQ=rbind(\n      c(0,    0.5000,    1.4142), #      ; ... %% '{AB} C D'   [1 1 2 3]   53\n      c(0,   -0.5000,    1.4142), #      ; ... %% '{AB} D C'   [1 1 3 2]   54\n      c(-0.5000,         0,   -1.4142), # ;...  %% '{CD} B A'   [3 2 1 1]   55\n      c(0.5000,         0,   -1.4142), #  ;...  %% '{CD} A B'   [2 3 1 1]   56\n      c(1.2500,    0.7500,   -0.3536), #  ;...  %% '{AC} D B'   [1 3 1 2]   57\n      c(0.7500,1.2500,0.3536),       #  ;...  %% '{AC} B D'   [1 2 1 3]   58\n      c(-1.2500,   0.7500,   -0.3536), #  ;...  %% '{BC} D A'   [3 1 1 2]   59\n      c(-0.7500,    1.2500,    0.3536), # ;...  %% '{BC} A D'   [2 1 1 3]   60\n      c(1.2500,   -0.7500,   -0.3536), #  ;...  %% '{AD} C B'   [1 3 2 1]   61\n      c(0.7500,   -1.2500,    0.3536), #  ;...  %% '{AD} B C'   [1 2 3 1]   62\n      c(-1.2500,   -0.7500,   -0.3536), # ;...  %% '{BD} C A'   [3 1 2 1]   63\n      c(-0.7500,   -1.2500,    0.3536) #  ;...  %% '{BD} A C'   [2 1 3 1]   64\n    )\n    \n    ranksSQ=rbind(c(1,1,2,3),c(1,1,3,2),c(3,2,1,1),c(2,3,1,1),c(1,3,1,2),c(1,2,1,3),\n                  c(3,1,1,2),c(2,1,1,3),c(1,3,2,1),c(1,2,3,1),c(3,1,2,1),c(2,1,3,1)\n    )\n    \n    #------------------------------------------------------------------------\n    \n    M_AB_CD=apply(rbind(c(0,0.5,1.4142),c(-0.5,0,1.4142),c(0,-0.5,1.4142),\n                        c(0.5,0,1.4142)),2,mean) # '{AB}{CD}'   [1 1 2 2]   65\n    \n    M_AC_BD=apply(rbind(c(1.25,0.75,0.3536),c(1.25,0.75,-0.3536),c(0.75,1.25,-0.3536),\n                        c(0.75,1.25,0.3536)),2,mean) #'{AC}{BD}'   [1 2 1 2] 66\n    \n    M_BC_AD=apply(rbind(c(-0.75,1.25,-0.3536),c(-1.25,0.75,-0.3536),c(-1.25,0.75,0.3536),\n                        c(-0.75,1.25,0.3536)),2,mean) # '{BC}{AD}'   [2 1 1 2] 67\n    \n    EMID=rbind(M_AB_CD, M_AC_BD, M_BC_AD, M_AB_CD*-1, M_AC_BD*-1, M_BC_AD*-1,MA*-1,MB*-1,MC*-1,MD*-1) \n    #M_AB_CD*-1 = '{CD}{AB}'   [2 2 1 1] 68\n    #M_AC_BD*-1 = '{BD}{AC}'   [2 1 2 1] 69\n    #M_BC_AD*-1;= '{AD}{BC}'   [1 2 2 1] 70\n    #MA*-1;=      '{BCD}A'   [2 1 1 1] 71\n    #MB*-1;=      '{ACD}B'   [1 2 1 1] 72\n    #MC*-1;=      '{ABD}C'   [1 1 2 1] 73\n    #MD*-1;=      '{ABC}D'   [1 1 1 2] 74\n    #last =        {ABCD}    [1 1 1 1] 75 \n    \n    rankres=rbind(c(1,1,2,2),c(1,2,1,2),c(2,1,1,2),c(2,2,1,1),c(2,1,2,1),\n                  c(1,2,2,1),c(2,1,1,1),c(1,2,1,1),c(1,1,2,1),c(1,1,1,2),c(1,1,1,1)\n    )\n    \n    \n    \n    \n    EE=rbind(E1,MA,E1T,E2,MB,E2T,E3,MC,E3T,E4,MD,E4T,ESQ,EMID)\n    coord=rbind(EE,apply(EE,2,mean))\n    ranks=rbind(ranksA,ranksB,ranksC,ranksD,ranksSQ,rankres)\n    \n    if (is.null(L)){\n      rr=labels(ranks,4,labs=2)\n    } else {\n      rr=labels(ranks,4,L,labs=1)\n    }\n    \n    \n    \n    plot3d(coord, type = 'p', xlab = '', ylab = '', zlab = '', add = T, \n           aspect = T, box = F, axes = F, col = 1)\n    \n    #exagon A first\n    segments3d(E1[c(1,2),], lwd=1, col = 1)\n    segments3d(E1[c(2,3),], lwd=1, col = 1)\n    segments3d(E1[c(3,4),], lwd=1, col = 1)\n    segments3d(E1[c(4,5),], lwd=1, col = 1)\n    segments3d(E1[c(5,6),], lwd=1, col = 1)\n    segments3d(E1[c(1,6),], lwd=1, col = 1)\n    segments3d(E1T[c(1,2),], lwd=0.5, col = 'gray')\n    segments3d(E1T[c(3,4),], lwd=0.5, col = 'gray')\n    segments3d(E1T[c(5,6),], lwd=0.5, col = 'gray')\n    #exagon B first\n    segments3d(E2[c(1,2),], lwd=1, col = 1)\n    segments3d(E2[c(2,3),], lwd=1, col = 1)\n    segments3d(E2[c(3,4),], lwd=1, col = 1)\n    segments3d(E2[c(4,5),], lwd=1, col = 1)\n    segments3d(E2[c(5,6),], lwd=1, col = 1)\n    segments3d(E2[c(1,6),], lwd=1, col = 1)\n    segments3d(E2T[c(1,2),], lwd=0.5,col = 'gray')\n    segments3d(E2T[c(3,4),], lwd=0.5,col = 'gray')\n    segments3d(E2T[c(5,6),], lwd=0.5,col = 'gray')\n    #exagon C first\n    segments3d(E3[c(1,2),], lwd=1, col = 1)\n    segments3d(E3[c(2,3),], lwd=1, col = 1)\n    segments3d(E3[c(3,4),], lwd=1, col = 1)\n    segments3d(E3[c(4,5),], lwd=1, col = 1)\n    segments3d(E3[c(5,6),], lwd=1, col = 1)\n    segments3d(E3[c(1,6),], lwd=1, col = 1)\n    segments3d(E3T[c(1,2),], lwd=0.5,col = 'gray')\n    segments3d(E3T[c(3,4),], lwd=0.5,col = 'gray')\n    segments3d(E3T[c(5,6),], lwd=0.5,col = 'gray')\n    #exagon D first\n    segments3d(E4[c(1,2),], lwd=1, col = 1)\n    segments3d(E4[c(2,3),], lwd=1, col = 1)\n    segments3d(E4[c(3,4),], lwd=1, col = 1)\n    segments3d(E4[c(4,5),], lwd=1, col = 1)\n    segments3d(E4[c(5,6),], lwd=1, col = 1)\n    segments3d(E4[c(1,6),], lwd=1, col = 1)\n    segments3d(E4T[c(1,2),], lwd=0.5,col = 'gray')\n    segments3d(E4T[c(3,4),], lwd=0.5,col = 'gray')\n    segments3d(E4T[c(5,6),], lwd=0.5,col = 'gray')\n    #squares\n    segments3d(rbind(E1[1,],E2[4,]), lwd=1, col = 1)\n    segments3d(rbind(E1[6,],E2[5,]), lwd=1, col = 1)\n    segments3d(rbind(E3[2,],E4[2,]), lwd=1, col = 1)\n    segments3d(rbind(E3[3,],E4[3,]), lwd=1, col = 1)\n    segments3d(rbind(E1[5,],E4[5,]), lwd=1, col = 1)\n    segments3d(rbind(E1[4,],E4[4,]), lwd=1, col = 1)\n    segments3d(rbind(E2[1,],E4[1,]), lwd=1, col = 1)\n    segments3d(rbind(E2[6,],E4[6,]), lwd=1, col = 1)\n    segments3d(rbind(E1[2,],E3[5,]), lwd=1, col = 1)\n    segments3d(rbind(E1[3,],E3[4,]), lwd=1, col = 1)\n    segments3d(rbind(E2[2,],E3[1,]), lwd=1, col = 1)\n    segments3d(rbind(E2[3,],E3[6,]), lwd=1, col = 1)\n    #other exagons\n    segments3d(rbind(ESQ[1,],ESQ[2,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[3,],ESQ[4,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[5,],ESQ[6,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[7,],ESQ[8,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[9,],ESQ[10,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[11,],ESQ[12,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(E1T[1,],E3T[3,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(E2T[3,],E3T[6,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(E1T[3,],E2T[1,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(E1T[5,],E4T[6,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(E2T[5,],E4T[3,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(E3T[1,],E4T[1,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[1,],E3T[2,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[6,],E2T[6,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[8,],E1T[6,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[2,],E4T[2,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[7,],E4T[5,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[5,],E4T[4,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[12,],E1T[2,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[10,],E2T[4,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[4,],E1T[4,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[9,],E3T[5,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[3,],E2T[2,]), lwd=0.5, col = 'gray')\n    segments3d(rbind(ESQ[11,],E3T[4,]), lwd=0.5, col = 'gray')\n    #-----------------------------\n    \n    if (is.null(X)){\n      indplot=matrix(1:75,ncol=1)\n    } else {\n      \n\n      #ranksinplot=ranks[apply(o, 2, any),]\n      \n      o2 = outer(seq_len(nrow(ranks)), seq_len(nrow(X)), Vectorize(\n        function(i, j) which(all(ranks[i,]==X[j,]))\n      ))\n      \n      indexing=o2==1\n      #print(indexing)\n      indexing[indexing==TRUE]=1\n      indexing[is.na(indexing)]=0\n      indplot=which(rowSums(indexing)==1)\n      #print(indplot)\n#       ranksinplot=ranks[indplot,]\n#       \n#       o = outer(seq_len(nrow(X)), seq_len(nrow(ranksinplot)), Vectorize(\n#         function(i, j) all(X[i,]==ranksinplot[j,])\n#       ))\n#       \n#       \n#       \n#       indexlabs=o==1\n#       #print(indexing)\n#       indexlabs[indexlabs==TRUE]=1\n#       indexlabs[is.na(indexlabs)]=0\n#       indlab=matrix(nrow=ncol(indexlabs),ncol=1)\n#       for (j in 1:nrow(indlab)){\n#         indlab[j,1]=which(indexlabs[j,]==1)\n#       }\n\n      \n      \n    }\n    #points(coord[indplot,1],coord[indplot,2],pch=16)\n    #points3d(coord[indplot,],col=\"blue\",cex=sqrt(100*((Wk/sum(Wk))/pi)))\n\n    if (is.null(Wk)){\n      \n      spheres3d(coord[indplot,],col=\"blue\",radius=0.02)\n      \n    } else {\n      \n      spheres3d(coord[indplot,],col=\"blue\",radius=sqrt(((Wk/sum(Wk))/(25*pi))))\n      \n    }\n    #text(tcoord[indplot,],rr[indplot,])\n    text3d(coord[indplot,1]+0.1, coord[indplot,2]+0.1, \n           coord[indplot,3]+0.1,rr[indplot,],col=1,cex=0.7)\n  }\n}\n",
    "created" : 1427357000974.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "89044819",
    "id" : "FB199962",
    "lastKnownWriteTime" : 1427720024,
    "path" : "~/R projects Antonio/ConsRank/R/ALL.r",
    "project_path" : "R/ALL.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}