


require(gtools)
require(rlist)
UN4=permutations(4,4)



#funzioni

#------------------------------------------------------------------------------------
order2rank=function(X,TO="{",TC="}"){
  #Given an ordering, it is transformed to a ranking 
  #input: 
  #X:  an ordering matrix or an ordering vector
  #TO: symbol that denotes the beginning of a block of ties. 
  #    Any symbol can be used, default is "{".
  #TC: symbol that denotes the end of a block of ties. 
  #    Any symbol can be used, default is "}".  
  #
  #IMPORTANT: check which symbol denotes tied rankings
  #
  #OUTPUT: the ranking matrix (or vector)
  
  Xl=X #duplicate the ordering
  
  if (is.null(nrow(X))){
    r=1
    c=length(X)
  } else {
    r=nrow(X)
    c=ncol(X)
  }
  
  
  # openb=unlist(gregexpr(pattern ='\\{',Xl))
  # closeb=unlist(gregexpr(pattern ='\\}',Xl))
  Xl=gsub(TO, "", Xl,fixed=TRUE)
  Xl=gsub(TC, "", Xl,fixed=TRUE)
  
  if (r==1){items=as.character(sort(Xl))}else{items=as.character(sort(Xl[1,]))}
  R=matrix(NA,r,c)
  colnames(R)=items
  Rref=seq(1:c)
  
  for (i in 1:r){
    if (r==1){ #if x is an ordering vector
      openb=unlist(gregexpr(pattern = TO, X, fixed=TRUE))
      closeb=unlist(gregexpr(pattern = TC, X, fixed=TRUE))
      
      if(sum(rowSums(cbind(openb,closeb))==-2)==c){ #if there are no ties
        
        for(j in 1:c){
          
          R[which(items==X[j])]=j
          
        }
        
      } else { #if there are ties
        check=FALSE
        pos=1
        iter=1
        id=rowSums(cbind(openb,closeb))
        ido=which(id==0)
        idc=which(id==1)
        iterid=1
        stp=0
        
        j=1
        while(check==FALSE){
          R[which(items==Xl[j])]=pos
          
          if (stp==1){ido=rep(0,iterid)}
          
          if (j==ido[iterid]){
            
            for (i in ido[iterid]:idc[iterid]){
              
              R[which(items==Xl[i])]=pos
              #if (i==idc[iterid]){pos=pos+1}
              
            }
            
            pos=pos+1
            j=idc[iterid]+1
            iterid=iterid+1
            
          } else {
            
            pos=pos+1
            j=j+1
            
          }
          
          
          #if(( j>c) || (iterid>length(idc) )){check=TRUE}
          if( j>c){check=TRUE}
          if(iterid>length(idc)){stp=1}
          
          
        } #end while
        
        
        
      }
      
    } else { #if X is an ordering matrix
      
      openb=unlist(gregexpr(pattern =TO, X[i,], fixed=TRUE))
      closeb=unlist(gregexpr(pattern =TC, X[i,], fixed=TRUE))
      
      if(sum(rowSums(cbind(openb,closeb))==-2)==c){ #if there are no ties
        
        for(j in 1:c){
          
          R[i,which(items==X[i,j])]=j
          
        }
        
      } else { #if there are ties
        check=FALSE
        pos=1
        iter=1
        id=rowSums(cbind(openb,closeb))
        ido=which(id==0)
        idc=which(id==1)
        iterid=1
        stp=0
        
        j=1
        while(check==FALSE){
          R[i,which(items==Xl[i,j])]=pos
          
          if (stp==1){ido=rep(0,iterid)}
          
          if (j==ido[iterid]){
            
            for (k in ido[iterid]:idc[iterid]){
              
              R[i,which(items==Xl[i,k])]=pos
              #if (i==idc[iterid]){pos=pos+1}
              
            }
            
            pos=pos+1
            j=idc[iterid]+1
            iterid=iterid+1
            
          } else {
            
            pos=pos+1
            j=j+1
            
          }
          
          
          #if(( j>c) || (iterid>length(idc) )){check=TRUE}
          if( j>c){check=TRUE}
          if(iterid>length(idc)){stp=1}
          
          
        } #end while
        
        
        
      }
      
    }# end if X is a matrix
    
    
  } #end principal loop (for i=1:r)
  
  return(R)
  
}#end function

#----------------------------------------------------------------------------------


rank2order = function (X,items=NULL,TO="{",TC="}",itemtype="L"){
  
  #Given a ranking, it is transformed into an ordering 
  #input: 
  #X:     a n by c ranking matrix or a 1 by c rank vector
  #TO:    symbol that denotes the beginning of a block of ties to be placed. 
  #       Any symbol can be used, default is "{".
  #TC:    symbol that denotes the end of a block of ties to be insert. 
  #       Any symbol can be used, default is "}".  
  #items: the items to be placed into the ordering matrix. Default are the
  #       first c small letters
  #itemtype:to be used only if items is not set. The default value is "L", namely
  #         letters. Any other symbol produces items as the first c integers
  #
  #OUTPUT: the ordering matrix (or vector)
  
  
  if(is.null(nrow(X))){
    r=1
    c=length(X)
    X=matrix(X,r,c)
  } else {
    r=nrow(X)
    c=ncol(X)
  }
  
  if(is.null(items)){
    
    if(itemtype=="L"){
      
      items=letters[seq(1:c)]
      
    } else {
      
      items=as.character(seq(1:c))
    }
  }
  
  out=matrix(0,r,c)
  
  for (i in 1:r){
    
    ord = rank(X[i,])
    orders = tapply(items, ord, sort)
    check=FALSE
    j=1
    h=1
    
    while(check==FALSE) {
      
      if (length(orders[[h]]) > 1) {
        
        k=length(orders[[h]])
        nams=matrix(orders[[h]],1,k)
        nams[1]=paste(TO, nams[1], sep="")
        nams[k]=paste(nams[k], TC, sep="")
        passo=seq(j,(j+k-1))
        out[i,passo]=nams
        j=passo[k]+1
        h=h+1
      } else {
        out[i,j] = paste(orders[[h]])#, collapse = " ")
        j=j+1
        h=h+1
      }
      
      if(h>length(orders)){check=TRUE}
      
    } #end for j
    
  } #end for i
  
  return(out)
}


#----------------------------------------------------------------------------------

Bell=function(n){
  # Compute the Bell's number. It is the number of all possible partitions
  # of the set {1:n}.
  # also it returns in column vector B all Bell's numbers from 1 to N
  
  if(n==0){
    b=1
    B=NULL
  } else {
    
    A = matrix(0,n,n)
    A[1,1] = 1
    
    for (j in 2:n){
      
      A[j,1] = A[j-1,j-1]
      
      for (i in 2:n){
        
        A[j,i] = A[j, i-1] + A[j-1,i-1]
      }
      
    }
    
    b = A[n,n]
    B=diag(A)
    
  }
  
  return(list(b=b,B=matrix(B,n,1)))
}
    
##----------------------------------------

Stirling2 = function(n,k){
#Stirling numbers of the second kind, denoting the
#number of ways to partition a set of n objects into k non-empty subsets
#
#input:  n (integer): the number of the objects
#        k (integer): the number of the non-empty subsets (buckets)
#
#output:
#        S:  the stirling number of the second kind
#        SM: the matrix showing, for each k (on the columns) in how many
#            ways the n objects (on the rows) can be partitioned
  
  if (k==0){
    
    if (n==0){S=1}else{S=0}
    
    SM=matrix(0,n,n)
    
  }  else  {
    
    SM=matrix(NA,n,k)
    SM[,1]=1
    
    ind = (1:k-1)*n+1:k
    
    SM[ind]=1
    
    for (i in 2:n){
      
      crit=min((i-1),k)
      if (crit>=2){
        
        for (j in 2:crit){
        
        SM[i,j]=SM[(i-1),(j-1)]+j*SM[(i-1),j]
        
        }
        
      }
      
    }
    
    S=SM[n,k]
    
    
  } #end else
  
  
  return(list(S=S, SM=SM))
  
}

#---------------------------------------------------------



insert = function(part,n,elements=NULL,stack=1){
  
  # perform all possible insertions
  
  #----preprocessing----------------------------------
  if(is.null(elements)){elements=letters[seq(1:n)]}
  
  if (length(part)==1){ #if1
    
    l=1 
    open=NULL
    close=NULL
    
  } else {
    
    if (!is.matrix(part)){part=matrix(part,1,length(part))}
    
    
    open=unlist(gregexpr(pattern ='\\{',part))
    close=unlist(gregexpr(pattern ='\\}',part))
    
    if (length(which(open>=1)) + length(which(close>=1)) == 0){ #if2
      
      
      l = ncol(part)
      
    } else {
      
      sequ=rowSums(cbind(apply(part,1,function(x) unlist(gregexpr(pattern ='\\{',part))),
                         apply(part,1,function(x) unlist(gregexpr(pattern ='\\}',part)))))
      
      #sequ=rbind(sequ,seq(1:length(sequ)))
      
      buckets=vector(mode="list")
      
      checka=FALSE
      
      i=1
      k=1
      inda=NA
      while(checka==FALSE){
        
        
        if (sequ[i]==0){  #if the sequence starts with a tied ranking
          checkb=FALSE
          while(checkb==FALSE){
            
            if (sequ[i]==1){
              
              inda=cbind(inda,i)
              inda=inda[-1]
              buckets[[k]]=part[inda]
              inda=NA
              
              k=k+1
              i=i+1
              checkb=TRUE
              
            } else {
              
              
              inda=cbind(inda,i)
              i=i+1
              
              
            }
            
            
          } #end while checkb
          
        } else if (sequ[i]==-2){ # if the sequence starts with an object not in a tie
          checkc=FALSE
          while(checkc==FALSE){
            inda=cbind(inda,i)
            inda=inda[-1]
            buckets[[k]]=part[inda]
            i=i+1
            k=k+1
            checkc=TRUE
          }
          
          
          
          # if (i==length(sequ)){
          #   inda=cbind(inda,i)
          #   inda=inda[-1]
          #   buckets[[k]]=part[inda]
          #   i=i+1
          #   checkc=TRUE
          # } else if (sequ[(i+1)]==0){
          #   
          #   inda=cbind(inda,i)
          #   inda=inda[-1]
          #   buckets[[k]]=part[inda]
          #   inda=NA
          #   i=i+1
          #   k=k+1
          #   checkc=TRUE
          #   
          # } else {
          #   
          #   
          #   inda=cbind(inda,i)
          #   i=i+1
          #   
          # } 
          
          # } #end while c
          
          
          
          
        } # end if statements
        
        
        if (i>length(sequ)){checka=TRUE}
        
        
      } #while 1
      
      l=length(buckets)
      
    }  #end if2
    
    
  }#end if1
  
  
  
  #---------end preprocessing---------------------------
  
  en = elements[n]
  if (stack==0){
    m=l
  } else if (stack==2){
    m = 1
  } else {
    m=l+1
  }
  
  
  part_i = vector(mode = "list", length = m)
  part_ib = vector(mode = "list", length = m)
  
  
  if (length(which(open>=1)) + length(which(close>=1)) == 0){ #if there are no ties
    
    if(stack<=1){#if stack <=1
      
      #for (j in 1:(m-1)){part_i[[j]]=part}
      
      for (i in 1:l){
        
        part_i[[i]]=part
        
        if (is.numeric(part_i[[i]])){part_i[[i]]=as.character(part_i[[i]])}
        
        indice=1:length(part_i[[i]])
        indice[indice>=i]=indice[indice>=i]+1
        part_ib[[i]][indice]=part_i[[i]]
        part_ib[[i]][i]=paste("{",part_i[[i]][i],sep="")
        part_ib[[i]][(i+1)]=paste(en,"}",sep="")
      }
      
    }#end if stack <=1
    
    if (stack>=1){
      
      part_ib[[m]]=as.character(cbind(part,en))
      
    }
    
  } else  {  #if there are ties
    
    if (stack<=1){ #if stack >=1
      
      for (i in 1:l){
        
        if (is.numeric(buckets[[i]])){buckets[[i]]=as.character(buckets[[i]])}
        
        buck=buckets[[i]]
        buck=gsub("\\{", "", buck)
        buck=gsub("\\}", "", buck)
        buck=cbind(list.cbind(buck),en)
        buck[1]=paste("{",buck[1],sep="")
        buck[length(buck)]=paste(buck[length(buck)],"}",sep="")
        rasp=buckets
        rasp[[i]]=buck
        part_ib[[i]]=unlist(rasp)
        
      }
      
    }#end if stack >=1
    
    if (stack>=1){
      part_ib[[m]]=as.character(cbind(list.cbind(unlist(buckets)),en))
    }
    
    
  } #end if there are no ties
  
  
  return(list.rbind(part_ib))
  
}



#-----------------------------------

partall2 = function(n, elements=NULL){
  
  
  # Return the cell list of all partitions of the integer set {1:n}
  # Output LIST is the cell of size (b x 1), where b is Bell number Bn
  # Each list{j} is a partition of {1:n}
  
  if(is.null(elements)){elements=letters[seq(1:n)]}
  
  if (n==1){
    
    lista=elements[n]
    
  } else {
    
    lp=partall2((n-1),elements) #recursive call to partall2
    
    if(is.null(nrow(lp))){k=length(lp)}else{k=nrow(lp)}
    
    for (i in 1:k){
      
      if(k==1){llp=lp[i]}else{llp=lp[i,]}
      
      pa=insert(llp,n,elements)
      if (i==1){lista=pa}else{lista=rbind(lista,pa)}
      
      
    }
    
  }
  
  return(lista)
}

#------------------------------------

partk=function(n,k,elements=NULL){
  
  if(is.null(elements)){elements=letters[seq(1:n)]}
  
  
  if(k==1){
    lista=matrix(elements,1,length(elements))
    lista[1]=paste("{",lista[1],sep="")
    lista[length(lista)]=paste(lista[length(lista)],"}",sep="")
  } else if (k==length(elements)) {
    lista=matrix(as.character(elements),1,length(elements))
  } else {
    

  
    m=n-k+1
  
    L=vector(mode="list", length=m)
  
    for (j in 1:m){
    
      L[[j]]=elements[1:j]
    
      if(j>1){
        L[[j]][1]=paste("{",L[[j]][1],sep="")
        L[[j]][length(L[[j]])]=paste(L[[j]][length(L[[j]])],"}",sep="")
      }
    
    }
  
    SN=Stirling2(n,k)
  
    for (kk in 2:k){ #for #2
    
      L[[1]]=elements[1:kk]
    
      for (j in 2:m){# for #3
      
        nu=j+kk-1
      
      #lista=vector(mode="list", length= SN$SM[nu,kk])
      
        lp=L[[j]]
      
        if(is.null(nrow(lp))){
          tt=1} else {
            tt=nrow(lp)
        }
      
        if(tt>1){
          for(i in 1:tt){
          part_i=insert(lp[i,],nu,elements,stack=2)
          if (i==1){lista1=part_i}else{lista1=rbind(lista1,part_i)}
          }
        } else {
        
          lista1=insert(matrix(lp,1,length(lp)),nu,elements,stack=2)
        }
      
        lp=L[[(j-1)]]
      
        if(is.null(nrow(lp))){
          tt=1} else {
            tt=nrow(lp)
          }
      
      
        if(tt>1){
        
          for(i in 1:tt){
          part_i=insert(lp[i,],nu,elements,stack=0)
          if (i==1){lista2=part_i}else{lista2=rbind(lista2,part_i)}
          }
        } else {
          lista2=insert(matrix(lp,1,length(lp)),nu,elements,stack=0)
        }
      
        L[[j]]=rbind(lista1,lista2)
      
      }#end for3
    
    }#end for2
      

  
  lista=L[[m]]
  }#end first if
  
  return(lista)
  
  
}#end function

#------------------------------------------


partitions = function(n,k=NULL,items=NULL,itemtype="L"){
  
  #generate all possible partitions of n items constrained into k non empty subsets
  #input: 
  #n:         a (integer) number denoting the number of items
  #k:         the number of the non-empty subsets. Default value is NULL,
  #           in this case all the possible partitions are displayed
  #items: the items to be placed into the ordering matrix. Default are the
  #       first c small letters
  #itemtype:to be used only if items is not set. The default value is "L", namely
  #         letters. Any other symbol produces items as the first c integers
  #
  #OUTPUT: the ordering matrix (or vector)
  #
  #example
  # X=partitions(4,3) #shows all the ways to partition 4 itemns (say "a", "b", "c" and "d" into 3 non-empty subets
  #                   #(i.e., into 3 buckets). The Stirling number of the second kind (4,3) indicates that there
  #                   #are 6 ways. The output is
  #                   #> X
  #                   #     [,1] [,2] [,3] [,4]
  #                   #[1,] "{a" "b}" "c"  "d" 
  #                   #[2,] "{a" "c}" "b"  "d" 
  #                   #[3,] "a"  "{b" "c}" "d" 
  #                   #[4,] "{a" "d}" "b"  "c" 
  #                   #[5,] "a"  "{b" "d}" "c" 
  #                   #[6,] "a"  "b"  "{c" "d}"
  #
  # X2=order2rank(X) #it transform the ordering into ranking   
  #                  #> X2
  #                  #     a b c d
  #                  #[1,] 1 1 2 3
  #                  #[2,] 1 2 1 3
  #                  #[3,] 1 2 2 3
  #                  #[4,] 1 2 3 1
  #                  #[5,] 1 2 3 2
  #                  #[6,] 1 2 3 3
  
  
  #check
  
  if(!is.null(k)){
    if(k>n) stop('k must be less or equal to n')
    if(k<=0 || (k%%1)!=0) stop('k must be positive integers')
  }
  
  if(n<=0 || n%%1 !=0) stop('n must be a positive integer')
  #end checks

  if(is.null(items)){
    
    if(itemtype=="L"){
      
      items=letters[seq(1:n)]
      
    } else {
      
      items=as.character(seq(1:n))
    }
  }
  
  if(is.null(k)){
    parts=partall2(n,items)
  } else {
    parts=partk(n,k,items)
  }
  
  
return(parts)  
  
}

#-----------------------------------------------------

allranks = function (X){
  
 #generate all possible rankings of n items given
 #the ranking X
 # allranks(order2rank(partall2(4)))
  
  
  if(is.null(nrow(X))){
    r=1
    c=length(X)
    X=matrix(X,r,c)
  } else {
    r=nrow(X)
    c=ncol(X)
  }
  
  
  ref=seq(1:c)
  out=matrix(NA,1,c)
  SS=NULL
  allperms=vector(mode="list")
  nb=rowSums(X)
  

  
  for (i in 1:r){
    
    if(nb[i]==c){
      allbuck=X[i,]
      SS=rbind(SS,-1)
    } else if(nb[i]==(c*(c+1)/2)) {
      allbuck=permutations(c,c)
      SS=rbind(SS,-1)
    } else {
      
      ord = rank(X[i,])
      orders = tapply(ref, ord, sort)
      SS=rbind(SS,length(orders))
      if(i==1){
        indici=permutations(length(orders),length(orders))
      } else {
        if(SS[i]!=SS[(i-1)]){
          indici=permutations(length(orders),length(orders))
          #SS=rbind(SS,length(orders))
        }
      }
      allbuck=matrix(NA,nrow(indici),c)
      for (j in 1:nrow(indici)){
        for (k in 1:length(orders)){
          id=unlist(orders[indici[j,k]])
          allbuck[j,id]=k
        }
      }
    } #end else
    out=rbind(out,allbuck)
    allperms[[i]]=allbuck
  }
    
  out=out[-1,]
  row.names(out)=NULL
  
  return(list(R=out,Parts=allperms))
}
##########################
allranksnew = function (X){
  
  #generate all possible rankings of n items given
  #the ranking X
  # allranks(order2rank(partall2(4)))
  
  
  if(is.null(nrow(X))){
    r=1
    c=length(X)
    X=matrix(X,r,c)
    nbuckts<-sortnbuckts<-length(unique(X)) #number of buckets in the ranking X
    ordnbuckts=1
#    walk=1
  } else {
    r=nrow(X)
    c=ncol(X)
    nbuckts=apply(X,1,function(x) length(unique(x))) #buckets for each ranking in X
    sortnbuckts=sort(nbuckts)
    ordnbuckts=order(nbuckts)
    X=X[ordnbuckts,]
#    walk=c(0,diff(sortnbuckts))
#    sortnbuckts=c(NA,sort(nbuckts))
  }
  

  
  
  ref=seq(1:c)
  out=matrix(NA,1,c)
  SS=NULL
  allperms=vector(mode="list")
  permsinbuck=vector(mode="list")
  nb=rowSums(X)
  
  
  buckid=1
  for (i in 1:r){
    
    if(nb[i]==c){
      allbuck=X[i,]
      SS=rbind(SS,-1)
    } else if(nb[i]==(c*(c+1)/2)) {
      allbuck=permutations(c,c)
      SS=rbind(SS,-1)
    } else {
      
      ord = rank(X[i,])
      orders = tapply(ref, ord, sort)
      SS=rbind(SS,length(orders))
      if(i==1){
        indici=permutations(length(orders),length(orders))
      } else {
        if(SS[i]!=SS[(i-1)]){
          indici=permutations(length(orders),length(orders))
          #SS=rbind(SS,length(orders))
        }
      }
      allbuck=matrix(NA,nrow(indici),c)
      for (j in 1:nrow(indici)){
        for (k in 1:length(orders)){
          id=unlist(orders[indici[j,k]])
          allbuck[j,id]=k
        }
      }
    } #end else
    
    out=rbind(out,allbuck)
    allperms[[i]]=allbuck

  }
  
  out=out[-1,]
  row.names(out)=NULL
  
  
    
    css=c(0,cumsum(table(sortnbuckts)))
    
    for (h in 1:(length(css)-1)){
      permsinbuck[[h]]=list.rbind(allperms[((css[h]+1):css[(h+1)])])
    }
  
  return(list(R=out,Parts=allperms,Univinbucket=permsinbuck))
}






      
