{
    "collab_server" : "",
    "contents" : "#' Core function in computing consensus ranking as defined by Emond and Mason (2002)\n#'\n#' Core function in computing consensus ranking as defined by Emond and Mason (2002), recalled by EMCons function\n#'\n#' @param RR A ranking\n#' @param cij combined input matrix\n#' @param Po current penalty\n#' @param PS If PS=true, it prints the evaluating branches\n#' @param FULL Default FULL=FALSE. If FULL=TRUE, the searching is limited to the space of complete rankings. FULL=TRUE if the function is called by BBFULL algorithm.\n#'\n#' @return median ranking\n#' \n#' @references Emond, E. J., and Mason, D. W. (2002). A new rank correlation coefficient with application to the consensus ranking problem. Journal of Multi-Criteria Decision Analysis, 11(1), 17-28.\n#' #\n#' D'Ambrosio, A., Amodio, S., and Iorio, C. (2015). Two algorithms for finding optimal solutions of the Kemeny rank aggregation problem for full rankings. Electronic Journal of Applied Statistical Analysis, 8(2), 198-213.\n#'\n#' @author Antonio D'Ambrosio \\email{antdambr@unina.it}\n#' \n#' @seealso \\code{\\link{EMCons}} Emond and Mason branch-and-bound algorithm\n#' @seealso \\code{\\link{BBFULL}} D'Ambrosio et al. branch-and-bound algorithm for full rankings\n#' \n#' @export\n\nBBconsensus2 = function(RR,cij,Po,PS=TRUE,FULL=FALSE) {\n  ##Core code for the computation of the consensus ranking. Branch-and-bound \n  ##algorithm by Emond and Mason\n  ForFULL=FULL\n  CR=RR\n  a = t(matrix(sort(RR)))\n  ord = t(matrix(order(RR)))\n  r=ReorderingBB(RR)\n  BR.R=r #initialize ranking\n  BR.P=0 #initialize penalty\n  WCi=1\n  lambda=1\n  nobj=ncol(RR)\n  while (WCi == 1){\n    if (PS==TRUE) {\n      dsp1=paste(\"round\",lambda,sep=\" \")\n      print(dsp1) \n    }\n    \n    for (k in 2:ncol(a)) { #primary loop: add the k^th better object ranked\n      \n      B = nrow(BR.R)    #branches size\n#      print(B)\n#      flush.console()\n      \n      b=1:k\n      \n      \n      for (nb in 1:B) { #Secondary loop:  check the branches created by \"nb\"\n        \n        BR.R[nb,] = ReorderingBB(t(matrix(BR.R[nb,])))\n        rpbr=branches(matrix(BR.R[nb,],1,),cij,b,Po,ord,matrix(BR.P[nb]),FULL=ForFULL)\n        R=rpbr$cR\n        Pbr=rpbr$pcR     \n#        print(nrow(R))\n#        flush.console()\n        \n        \n        if (is.null(R)) {\n          \n          #if (nb==1) {\n          #\n          #    JR=0\n          #    \n          #    next\n          #    \n          #} else {     \n          \n          next\n          \n          #}\n        } else {         #process good rankings\n          \n          if (nb==1) {     #starting point\n            \n            #JR=nrow(R)\n            \n            KR.R=R\n            KR.P=Pbr\n            \n            \n            \n          } else {   #it is not the starting point\n            \n            KR.R=rbind(KR.R,R)\n            KR.P=rbind(KR.P,Pbr)\n            \n            \n          }\n          \n        }\n        \n        #JR = nrow(KR.R)  #update size of branches\n        \n      } #end secondary loop\n      \n      if (is.null(R)) {\n        \n        if (nb==B & nb!=1) { #If at the last iteration of the secondary loop all of thye rankings are not good \n          \n          rm(BR.R) #BR.R = NULL    #rm(BR.R)\n          rm(BR.P) #BR.P = NULL    #rm(BR.P)\n          BR.R = KR.R\n          BR.P = KR.P\n          KR.R = NULL\n          KR.P = NULL\n          #rm(JR) #JR = NULL\n          \n        } else {\n          \n          next\n          \n        }\n        \n      } else {\n        \n        rm(BR.R) #BR.R = NULL  #rm(BR.R)\n        rm(BR.P) #BR.P = NULL  #rm(BR.P)\n        BR.R = KR.R\n        BR.P = matrix(KR.P)\n        KR.R = NULL\n        KR.P = NULL        \n#        KR.R = NULL\n#        KR.P = NULL\n        #rm(JR)  #JR = NULL\n        \n      }\n      \n      if (PS==TRUE) {\n        \n        dsp2=paste(\"evaluating\",B,\"branches\",sep=\" \")\n        print(dsp2)\n        \n      }\n      \n    } #end primary loop\n    \n    #AccPen = BR.P\n    \n    \n    SSP=matrix(which(BR.P==min(BR.P)))\n    MinP=min(BR.P)\n    PenMin=Po-MinP\n    \n    if (PenMin==0) {\n      \n      #CR=t(matrix(BR.R[SSP,]))\n      CR=matrix(BR.R[SSP,],length(SSP),nobj)\n      WCi = 0\n      \n    } else {\n      \n      Po=MinP\n      WCi=1\n      lambda=lambda+1\n      #nRR=t(matrix((BR.R[SSP[1],])))\n      nRR=matrix((BR.R[SSP[1],]),1,nobj)\n      rm(BR.R)\n      rm(BR.P)\n      BR.R=nRR\n      BR.P=0\n      a = t(matrix(sort(BR.R)))\n      ord = t(matrix(order(BR.R)))\n      rm(nRR)\n      \n    }\n    \n  }   #end while\n  \n  CR\n}\n",
    "created" : 1492611641484.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1617500132",
    "id" : "7109E32",
    "lastKnownWriteTime" : 1492616383,
    "last_content_update" : 1492616383650,
    "path" : "~/R projects Antonio/ConsRank/R/BBconsensus2.R",
    "project_path" : "R/BBconsensus2.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 15,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}