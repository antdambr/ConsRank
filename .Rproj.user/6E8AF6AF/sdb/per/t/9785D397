{
    "collab_server" : "",
    "contents" : "#' Differential Evolution algorithm for Median Ranking\n#'\n#' Core function of the DECOR algorithm \n#'\n#' @param cij combined input matrix\n#' @param NJ the number of judjes\n#' @param NP The number of population individuals\n#' @param L Generations limit: maximum number of consecutive generations without improvement\n#' @param FF The scaling rate for mutation. Must be in [0,1]\n#' @param CR The crossover range. Must be in [0,1]\n#' @param FULL Default FULL=FALSE. If FULL=TRUE, the searching is limited to the space of full rankings. In this case, the data matrix must contain full rankings.\n#' \n#' @return a \"list\" containing the following components:\n#' \\tabular{lll}{\n#' ConsR \\tab  \\tab the Consensus Ranking\\cr\n#' Tau \\tab       \\tab averaged TauX rank correlation coefficient\\cr\n#' besti\\tab   \\tab matrix of best individuals for every generation\\cr\n#' bestc\\tab  \\tab vector of best individuals' cost for every gen\\cr\n#' bests\\tab   \\tab  \\cr vector of best individuals\n#' avgTau\\tab   \\tab  \\cr maximum average tauX\n#' Eltime\\tab  \\tab Elapsed time in seconds}\n#' \n#' \n#' @author Antonio D'Ambrosio \\email{antdambr@unina.it} and Giulio Mazzeo \\email{giuliomazzeo@gmail.com}\n#' \n#' @references D'Ambrosio, A., Mazzeo, G., Iorio, C., and Siciliano, R. (2017). A differential evolution algorithm for finding the median ranking under the Kemeny axiomatic approach. Computers and Operations Research, vol. 82, pp. 126-138. \n#' \n#' @export\n\n\n\n\nDECORcore = function(cij,NJ,NP=15,L=50,FF=0.4,CR=0.9,FULL=FALSE){\n  \n  # DECoR Differential Evolution for COnsensus Ranking\n  \n  # Discrete version of Differential Evolution algorithm\n  # specifically created for solving the Consensus Ranking problem,\n  # AKA social choice, AKA rank aggregation.\n  # This file uses external functions for mutation and crossover during\n  # the genetic evolutions of population.\n  # Another function is needed to discretize and correct child solutions\n  # when mutation and crossover generate out-of-bound values and duplicates.\n  #\n  # Input parameters:\n  #\n  # NP            - The number of population individuals\n  #\n  # L             - Generations limit: maximum number of consecutive \n  #                 generations without improvement\n  #\n  # F             - The scaling rate for mutation. Must be in [0,1]\n  #\n  # CR            - The crossover range. Must be in [0,1]\n  #\n  # cij           - Combined input matrix (see Emond and Mason B&B)\n  #\n  # NJ            - Number of judges (needed for cost computation)\n  #\n  # FULL          - FULL = 1 search in the space of full rankings\n  #\n  # Output parameters:\n  #\n  # besti         - Best Individuals:\n  #                 matrix of best individuals for every generation\n  #\n  # bestc         - Best Costs:\n  #                 vector of best individuals' cost for every gen\n  #\n  # bests         - Best Solutions:\n  #                 matrix with \"all\" the best solutions (founded)\n  #                 for checking if more than one optimal solution is found\n  #\n  # Notes:\n  #\n  # mutation      - rand/1/bin > best/1/bin\n  # \n  #Authors : Giulio Mazzeo and Antonio D'Ambrosio\n  \n  \n  # preparation\n  \n  tic = proc.time()[3]\n  N=nrow(cij)        # number of objects                     \n  costs       = matrix(0,1,NP)  # array of initial costs\n  \n  # initialize the population (random selection)\n  population = matrix(0,(NP-1),N)\n  \n  for (k in 1:(NP-1)){ population[k,] = sample(N)}\n  \n  \n  # insert a very good candidate\n  \n  population=rbind(population,findconsensusBB(cij))\n  \n  if (FULL==TRUE){\n    population[NP,]=order(population[NP,])\n  }\n  \n  \n  \n  # compute costs of initial population\n  costs=matrix(0,NP,1)\n  taos=costs\n  for (i in 1:NP){\n    \n    COTA=combincost(population[i,],cij,NJ)\n    costs[i]=COTA$cp\n    taos[i]=COTA$tp\n  }\n  \n  # store the best individual and cost of initial population\n  bestc = min(costs)\n  bestind = which(costs==min(costs))\n  bestT = max(taos)\n  besti=population[bestind,]\n  \n  \n  # generation index\n  g = 2\n  \n  # evolve for generations\n  no_gain = 0\n  \n  while (no_gain < L){\n    \n    \n    # individuals mutation\n    for (i in 1:NP){\n      \n      \n      # apply mutation\n      evolution = mutaterand1(population,FF,i);\n      \n      # apply crossover\n      evolution = crossover(population[i,],evolution,CR)\n      \n      \n      # apply discretization and convert to rank\n      \n      if (FULL==TRUE){\n        \n        evolution=order(evolution)}\n      \n      else{\n        \n        evolution = childtie(evolution)\n      }\n      \n      # apply selection, hold the best individual\n      COTAN = combincost(evolution,cij,NJ)\n      cost_new=COTAN$cp\n      ta_new=COTAN$tp\n      \n      \n      if (cost_new < costs[i]){\n        population[i,] = evolution\n        costs[i] = cost_new\n        taos[i]=ta_new\n      }\n      \n    }\n    \n    # store the best individual of current generation\n    \n    bestco = min(costs)\n    bestc=rbind(bestc,bestco)\n    bestind = which.min(costs)\n    bestTa = max(taos)\n    bestT=rbind(bestT,bestTa)\n    bestin=population[bestind,]\n    besti=rbind(besti,bestin)\n    \n    \n    # check if this generation improved solutions\n    if (bestc[g] == bestc[(g-1)]){\n      \n      no_gain = no_gain + 1}\n    \n    else{\n      \n      no_gain = 0\n    }\n    \n    \n    # next generation\n    g = g + 1\n    \n  } #end while\n  \n  # select ALL the best solutions\n  \n  indexes = which(bestc==min(bestc))\n  if (FULL==TRUE){ #if1\n    \n    if (length(indexes)==1){ #if2\n      bests=childclosint(matrix(besti[indexes,],1,N))}\n    else{\n      bests=matrix(0,length(indexes),N)\n      for (j in 1:length(indexes)){\n        bests[j,]=childclosint(besti[indexes[j],])\n      } #end for\n    } #end if2\n    \n  } else { #if FULL = FALSE\n    \n    if(length(indexes)==1){\n      \n      bests = reordering(matrix(besti[indexes,],1,N))\n      \n    } else {\n      \n      bests = reordering(besti[indexes,])}\n    \n  } #end if1\n  \n  avgTau = bestT[indexes]\n  \n  ConsR=unique(bests)\n  Tau=matrix(rep(avgTau,nrow(ConsR)),nrow(ConsR),1)\n  \n  \n  toc = proc.time()[3]\n  eltime=toc-tic\n  return(list(ConsR=ConsR,Tau=Tau,besti=besti,bestc=bestc,bests=bests,avgTau=avgTau,bestT=bestT,Eltime=eltime))\n  \n}\n",
    "created" : 1491654302164.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1003538003",
    "id" : "9785D397",
    "lastKnownWriteTime" : 1491673066,
    "last_content_update" : 1491673066616,
    "path" : "~/R projects Antonio/ConsRank/R/DECORcore.R",
    "project_path" : "R/DECORcore.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}