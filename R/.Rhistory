Outputs2=VeraTransf(Objects,Indiv,Interaction)
Delta=Outputs2$Delta
lambda=Outputs2$lambda
beta=Outputs2$beta
gamma=Outputs2$gamma
TauX=diag(Tau_X(X,Interaction))
CorK=diag(cor((X),(Interaction),method="kendall",use="pairwise"))
CorS=diag(cor((X),(Interaction),method="spearman",use="pairwise"))
MTau=mean(TauX)
MKendall=mean(CorK)
MSpearman=mean(CorS)
nr=c("TauX","Kendall","Sperman")
nc=c("Average","Min","Max")
resume = data.frame(cbind( rbind(MTau,MKendall,MSpearman), rbind(min(TauX),min(CorK),min(CorS)),
rbind(max(TauX),max(CorK),max(CorS)) ))
colnames(resume)=nc
row.names(resume)=nr
if (printscr==TRUE){
print(resume)
}
return(list (Delta=Delta, Interaction=Interaction, Objects=Objects,
Indiv=Indiv, lambda=lambda, beta=beta, gamma=gamma, resume=resume) )
} else if (transform=="Van_Deun"){
Delta=VanDeunTransf(X)$Delta
Interaction=Delta[1:nind,(nind+1):(nind+nobj)]
TauX=diag(Tau_X(X,Interaction))
CorK=diag(cor(t(X),t(Interaction),method="kendall",use="pairwise"))
CorS=diag(cor(t(X),t(Interaction),method="spearman",use="pairwise"))
MTau=mean(TauX)
MKendall=mean(CorK)
MSpearman=mean(CorS)
nr=c("TauX","Kendall","Sperman")
nc=c("Average","Min","Max")
resume = data.frame(rbind( cbind(MTau,MKendall,MSpearman), cbind(min(TauX),min(CorK),min(CorS)),
cbind(max(TauX),max(CorK),max(CorS)) ))
colnames(resume)=nc
row.names(resume)=nr
if (printscr==TRUE){
print(resume)
}
return(list (Delta=Delta, Interaction=Interaction, Objects=NULL,
Indiv=NULL, lambda=NULL, beta=NULL, gamma=NULL,resume=resume) )
}
}
PreprocessingTauX=function(X){
# X is a n times c rectangular matrix,
# with n individuals and c items
c=ncol(X)
# generate matrix of centers of gravity of the objects
obj=matrix(2,c,c)
for (k in 1:c){
obj[k,k]=1
}
Interaction = 1-Tau_X(X,obj)
Interaction=as.matrix(Interaction)
Objects = 1-TauXDistObj(X)
Objects=as.matrix(Objects)
Indiv = 1-Tau_X(X)
Indiv=as.matrix(Indiv)
Ds = rbind(  cbind(Indiv,Interaction), cbind(t(Interaction),Objects) )
return(list(Interaction=Interaction,Objects=Objects,Indiv=Indiv,Ds=Ds))
}
VectTauX=function(X,Y){
trxy=c(X)
xy=c(Y)
k=0
for (j in 1:length(trxy)){
k=k+sum((2*(trxy[j]<=trxy[setdiff(seq(1,length(xy)),j)])-1)*(2*(xy[j]<=xy[setdiff(seq(1,length(xy)),j)])-1))
}
Tx=k/((length(xy)*(length(xy)-1)))
return(Tx)
}
TauXDistObj = function(X){
c = ncol(X)
pw = combinations(c,2);
D = matrix(0,c,c)
for (j in 1:nrow(pw)){
D[pw[j,1],pw[j,2]] = VectTauX(X[,pw[j,1]],X[,pw[j,2]])
}
D=D+t(D)+diag(1,c);
return(D)
}
VeraTransf = function(Objects,Indiv,Interaction){
Objects=as.matrix(Objects)
Indiv=as.matrix(Indiv)
Interaction=as.matrix(Interaction)
nobj=nrow(Objects)
nind=nrow(Indiv)
lambda=sqrt(nobj^2/sum(sum(Objects^2)))
Objects1=lambda*Objects
beta=sqrt(nind^2/sum(sum(Indiv^2)))
Indiv1=beta*Indiv
gamma=sqrt((nind*nobj)/sum(sum(Interaction^2)))
Interaction1=gamma*Interaction
Delta1=rbind(Objects1,Interaction1) #Matriz bloque columna: n+R x n
Delta2=rbind(t(Interaction1),Indiv1) #Matriz bloque columna: R x n+R
#individuals on the top
Delta=rbind( cbind(Indiv1,Interaction1), cbind(t(Interaction1), Objects1) )
return( list (Delta=Delta,lambda=lambda, beta=beta, gamma=gamma))
}
###################################################################################
VanDeunTransf = function(X){
#Given a rectangualr matrix X of dimension n x m
#containing preferences, transform the matrix into a
#dissimilarity matrix (n+m) x (n+m) according the approach
#by Van Deun, Heiser and Delbeke (2007)
#
#Output: Delta
n=dim(X)[1]
m=dim(X)[2]
nr=row.names(X)
if (is.null(nr)){nr=seq(1:n)}
nc=colnames(X)
#if (is.null(nc)){nc=letters[seq(1:m)]}
C=matrix((m+1)/2,(n+m),m) #center of geometrical space
# step 1: create the objects vectors
obj = matrix(0,m,m)
#scalefact1=sqrt((m*(2*m+1)*(m+1))/6)
for (j in 1:m){
obj[j,j]=1
obj[j, setdiff(c(1:m),j)] = 1+m/2
#    obj[j,]=scalefact1*obj[j,]/norm(matrix(obj[j,]),type="f")
}
# obj=obj*scalefact1
X=rbind(as.matrix(X),obj)
row.names(X)=c(nr,nc)
#step 2: center the matric with trespect to C
Xc=X-C
#step 3: Scale the object vectors
scalefact=sqrt((m+1))/sqrt(3)
Xc[(n+1):(n+m),]=Xc[(n+1):(n+m),]*scalefact
#step4: compute the squared Euclidean distance among
#the rows of the matrix
XcS=matrix(0,(n+m),m)
#scalefact2=sqrt( (m*(m^2-1)/12) )
scalefact2=sqrt((m*(2*m+1)*(m+1))/6)
for (j in 1:(n+m)){
XcS[j,]=scalefact2*Xc[j,]/norm(matrix(Xc[j,]),type="f")
}
rownames(XcS)=rownames(X)
Delta = dist(XcS)^2
D=as.matrix(Delta)
return(list(Delta=D, Interactions=D[(1:n),(n+1):(n+m)], Xc=Xc, XcS=XcS))
}
###########################################################################
##plotting
MDSplot_unf=function(sol){
#sol is the output of the function "UNFOLDING_CORR"
fitR=sol$RowCoord
fitC=sol$ColCoord
Interactions=sol$Interactions
nr=sol$n_i
nc=sol$n_c
tots=sol$tots
fitd_norm=sol$confdist
dhat_unf=sol$dhat_unf
#############################
#--Plotting
par(c(09, 0.9, 0.9, 0.9))
par(mfrow=c(1,1))
plot(fitR[,1],fitR[,2],type = "p", pch = 20, cex = .5, col="darkgray",main="Unfolding")
text(fitR[,1],fitR[,2],c(1:nr),col="darkgray")
points(fitC[,1],fitC[,2],col=2)
text(fitC[,1],fitC[,2],colnames(Interactions))
mds_sol=sol$mdssol
#Shepard plots
fitd_normUnf=fitd_norm[1:nr,(nr+1):tots]
asvInt=as.vector(Interactions)
asvFit=as.vector(fitd_normUnf)
asvHat=as.vector(dhat_unf)
iord=order(asvInt,asvFit)
par(mfrow=c(1,2))
plot(asvInt,asvFit,type = "p", pch = 20, cex = .5, col = "darkgray", main="Shepard Unfolding")
points(asvInt[iord],asvHat[iord],col=2, type = "l")
#Shepard plot overall solution
plot(mds_sol,plot.type="Shepard",main="Shepard Overall")
par(mfrow=c(1,1))
}
unfplot = function(X,labs,x1=1,x2=1,trlis=FALSE,kx=0,ky=0){
##X musr be of the class "smacof"
rcoord=X$RowCoord
ccoord=X$ColCoord
# scegli lunghezza assi
if (trlis==TRUE){
trellis.device(color=FALSE)
par(mfrow=c(1,1), pty="s")
}
plot(rcoord[,1]*x1,rcoord[,2]*x2,cex=0.6,xlim=range((rcoord[,1]*x1)-kx,(ccoord[,1]*x1)+kx),ylim=range((rcoord[,2]*x2)-ky,(ccoord[,2]*x2)+ky),xaxt="n",yaxt="n",xlab="",ylab="")
points(ccoord[,1]*x1,ccoord[,2]*x2,col="red")
text(ccoord[,1]*x1+0.04,ccoord[,2]*x2+0.02,labs)
}
solunf <- UNFOLDING_CORR(sports)
sports
solunf <- UNFOLDING_CORR(sports)
p=2
maxiter=500
diffstress=0.000001
,
mdstype="ordinal"
mdstype="ordinal"
mdsties="primary"
start="torgerson"
DeltaTransf="Tau_X"
printscr=TRUE
X=sports
Delta=PrepareMatrix(X,transform=DeltaTransf,printscr)
n_ind=nrow(X) # number of individuals
n_col=ncol(X) #number of items
tots=n_ind+n_col #row_points + col_points
mds_sol=mds(Delta$Delta,ndim=p,type=mdstype,
ties=mdsties,init=start,
itmax=maxiter,eps=diffstress)
dhat=as.matrix(mds_sol$dhat) #dhat
fitd=as.matrix(dist(mds_sol$conf)) #fitted distances
fitd_norm=as.matrix(mds_sol$confdist) #configuration distance
fitR=mds_sol$conf[1:n_ind,] #coordinates of individuala
fitC=mds_sol$conf[(n_ind+1):tots,] #coordinates of items
dhat_unf=dhat[1:n_ind,(n_ind+1):tots] #dhat interactions
fitd_unf=fitd[1:n_ind,(n_ind+1):tots] #fitted distances unfolding
fitconf_unf=fitd_norm[1:n_ind,(n_ind+1):tots] #configuration distance unfolding
#-----Stress measures for both entire cofiguration and unfolding------------
#stress measures entire configuration
#RawStress=sum((dhat-fitd)^2) #Raw Stress
RawStress=mds_sol$stress^2*sum(dhat^2) #Raw Stress
#NormRawStress=RawStress/sum(dhat^2) #Normalized raw Stress
NormRawStress=mds_sol$stress^2 #Normalized raw Stress
Stress_1=mds_sol$stress #Stress-1
#stress measures for unfolding
RawStress_unf=sum((dhat_unf-fitd_unf)^2) #Raw Stress unfolding
NormRawStress_unf=RawStress_unf/sum(dhat_unf^2) #Normalized raw Stress unfolding
Stress_1unf=sqrt(NormRawStress_unf) #Stress-1 Unfolding
#----------------------------------------------
#DAF and Tucker
DAF=1-NormRawStress #Dispersion Accounted For overall solution
Tucker=sqrt(1-NormRawStress) #Tucker coefficient
DAF_unf=1-NormRawStress_unf #Dispersion Accounted For overall solution unfolding
Tucker_unf=sqrt(1-NormRawStress_unf) #Tucker coefficient unfolding
VAF=cor(c(dhat_unf),c(fitd_unf))^2
#loop for computing Shepard index
h=0
xy=as.vector(fitd_unf)
for (j in 1:length(xy)){
h=h+sum((1* ((xy[j]-xy[setdiff(1:length(xy),j)])/(xy[j]+xy[setdiff(1:length(xy),j)]) > 0.1)))
}
ShepardDindex= 2*h/(length(xy)*(length(xy)-1)) #Shepard index
dxy=mean(xy)
dx=mean(as.dist(fitd[1:n_ind,1:n_ind]))
dy=mean(as.dist(fitd[(n_ind+1):tots,(n_ind+1):tots]))
I1=log((dx/dxy))
I2=log((dy/dxy))
I3=log((dx/dy))
DeSarboIndex=sum(c(I1^2, I2^2, I3^2)) #De Sarbo's Index
dij=fitd_unf
trdij=dhat_unf
fitTauX=VectTauX(as.vector(dij),as.vector(trdij))
fitSpearman=cor(as.vector(dij),as.vector(trdij),method="spearman",use="pairwise")
fitKendall=cor(as.vector(dij),as.vector(trdij),method="kendall",use="pairwise")
################################################################################
##one day, for row-conditional case, these codes are ok                        #
#fitSpearman=mean(diag(cor(t(dij),t(trdij),method="spearman",use="pairwise"))) #
#fitKendall=mean(diag(cor(t(dij),t(trdij),method="kendall",use="pairwise")))   #
#fitTauX=mean(diag(Tau_X(dij,trdij)))                                          #
################################################################################
#----------------------------------------------------------------------------------------
#first resume measures
nc=c("RawStress","NormalizedRawStress","Stress-1","DAF","Tucker")
resumeall = data.frame(rbind(RawStress,NormRawStress,Stress_1,DAF,Tucker))
row.names(resumeall)=nc
colnames(resumeall)="MDS Measures"
nc_unf=c("RawStress","NormalizedRawStress","Stress-1","DAF","Tucker","VAF","Spearman",
"Kendall","TauX","Shepard","DeSarbo")
resume_unf = data.frame(rbind(RawStress_unf,NormRawStress_unf,Stress_1unf,DAF_unf,
Tucker_unf,VAF,fitSpearman,fitKendall,
fitTauX,ShepardDindex,DeSarboIndex))
row.names(resume_unf)=nc_unf
colnames(resume_unf)="Unfolding Measures"
AV_recov_pref=matrix(1,n_ind,(n_col*(n_col-1)/2))*999
AV_pearson=matrix(0,n_ind,1)
AV_Spearman=AV_pearson
AV_Kendall=AV_pearson
AV_Tau_X=AV_pearson
#dij=fitd_unf
for (j in 1:n_ind){
XX=t(X[j,])
DD=t(dij[j,])
ps=1
for (k in 1:(n_col-1)){
AV_recov= ( (sign(XX[k]-XX[setdiff(k:length(XX),k)])>=0)*2-1 ) ==  ( (sign(DD[k]-DD[setdiff(k:length(DD),k)])>=0)*2-1 )
ending=(ps-1)+length(AV_recov)
AV_recov_pref[j,ps:ending]=t(AV_recov) #averaged recovered preferences
ps=ending+1
}
#    print(j)
#    print(class(t(X[j,])))
#    print(dim(t(X[j,])))
#    print(class(t(dij[j,])))
#    print(dim(t(dij[j,])))
AV_pearson[j,1]=cor(t(X[j,]),as.matrix(dij[j,])) #averaged Pearson correlation
AV_Spearman[j,1]=cor(t(X[j,]),as.matrix(dij[j,]),method='spearman',use="pairwise") #averaged Spearman correlation
AV_Kendall[j,1]=cor(t(X[j,]),as.matrix(dij[j,]),method='kendall',use="pairwise") #averaged Kendall tau correlation
AV_Tau_X[j,1]=Tau_X(X[j,],t(dij[j,])) #averaged Tau_X correlation
}
#dij=fitd_unf
for (j in 1:n_ind){
XX=t(X[j,])
DD=t(dij[j,])
ps=1
for (k in 1:(n_col-1)){
AV_recov= ( (sign(XX[k]-XX[setdiff(k:length(XX),k)])>=0)*2-1 ) ==  ( (sign(DD[k]-DD[setdiff(k:length(DD),k)])>=0)*2-1 )
ending=(ps-1)+length(AV_recov)
AV_recov_pref[j,ps:ending]=t(AV_recov) #averaged recovered preferences
ps=ending+1
}
#    print(j)
#    print(class(t(X[j,])))
#    print(dim(t(X[j,])))
#    print(class(t(dij[j,])))
#    print(dim(t(dij[j,])))
AV_pearson[j,1]=cor(t(X[j,]),as.matrix(dij[j,])) #averaged Pearson correlation
AV_Spearman[j,1]=cor(t(X[j,]),as.matrix(dij[j,]),method='spearman',use="pairwise") #averaged Spearman correlation
AV_Kendall[j,1]=cor(t(X[j,]),as.matrix(dij[j,]),method='kendall',use="pairwise") #averaged Kendall tau correlation
AV_Tau_X[j,1]=Tau_X(X[j,],t(dij[j,])) #averaged Tau_X correlation
}01
j=1
x(X[j,])
t(X[j,])
class(t(X[j,]))
XX=t(X[j,])
DD=t(dij[j,])
ps=1
n_col
for (k in 1:(n_col-1)){
AV_recov= ( (sign(XX[k]-XX[setdiff(k:length(XX),k)])>=0)*2-1 ) ==  ( (sign(DD[k]-DD[setdiff(k:length(DD),k)])>=0)*2-1 )
ending=(ps-1)+length(AV_recov)
AV_recov_pref[j,ps:ending]=t(AV_recov) #averaged recovered preferences
ps=ending+1
}
#    print(j)
#    print(class(t(X[j,])))
#    print(dim(t(X[j,])))
#    print(class(t(dij[j,])))
#    print(dim(t(dij[j,])))
AV_pearson[j,1]=cor(t(X[j,]),as.matrix(dij[j,])) #averaged Pearson correlation
t(X[j,])
as.matrix(dij[j,])
t(as.matrix(dij[j,]))
#    print(j)
#    print(class(t(X[j,])))
#    print(dim(t(X[j,])))
#    print(class(t(dij[j,])))
#    print(dim(t(dij[j,])))
AV_pearson[j,1]=cor(t(X[j,]),t(as.matrix(dij[j,]))) #averaged Pearson correlation
t(X[j,])
X[j,]
#    print(j)
#    print(class(t(X[j,])))
#    print(dim(t(X[j,])))
#    print(class(t(dij[j,])))
#    print(dim(t(dij[j,])))
##poi vedrai
AV_pearson[j,1]=cor(matrix(X[j,],ncol=1),as.matrix(dij[j,])) #averaged Pearson correlation
AV_Spearman[j,1]=cor(matrix(X[j,],ncol=1),as.matrix(dij[j,]),method='spearman',use="pairwise") #averaged Spearman correlation
AV_Kendall[j,1]=cor(matrix(X[j,],ncol=1),as.matrix(dij[j,]),method='kendall',use="pairwise") #averaged Kendall tau correlation
AV_Tau_X[j,1]=Tau_X(X[j,],t(dij[j,])) #averaged Tau_X correlation
solunf <- UNFOLDING_CORR(sports)
UNFOLDING_CORR=function(X,p=2,maxiter=500,diffstress=0.000001,
mdstype="ordinal",mdsties="primary",start="torgerson",
DeltaTransf="Tau_X",printscr=TRUE){
Delta=PrepareMatrix(X,transform=DeltaTransf,printscr)
n_ind=nrow(X) # number of individuals
n_col=ncol(X) #number of items
tots=n_ind+n_col #row_points + col_points
mds_sol=mds(Delta$Delta,ndim=p,type=mdstype,
ties=mdsties,init=start,
itmax=maxiter,eps=diffstress)
dhat=as.matrix(mds_sol$dhat) #dhat
fitd=as.matrix(dist(mds_sol$conf)) #fitted distances
fitd_norm=as.matrix(mds_sol$confdist) #configuration distance
fitR=mds_sol$conf[1:n_ind,] #coordinates of individuala
fitC=mds_sol$conf[(n_ind+1):tots,] #coordinates of items
dhat_unf=dhat[1:n_ind,(n_ind+1):tots] #dhat interactions
fitd_unf=fitd[1:n_ind,(n_ind+1):tots] #fitted distances unfolding
fitconf_unf=fitd_norm[1:n_ind,(n_ind+1):tots] #configuration distance unfolding
#-----Stress measures for both entire cofiguration and unfolding------------
#stress measures entire configuration
#RawStress=sum((dhat-fitd)^2) #Raw Stress
RawStress=mds_sol$stress^2*sum(dhat^2) #Raw Stress
#NormRawStress=RawStress/sum(dhat^2) #Normalized raw Stress
NormRawStress=mds_sol$stress^2 #Normalized raw Stress
Stress_1=mds_sol$stress #Stress-1
#stress measures for unfolding
RawStress_unf=sum((dhat_unf-fitd_unf)^2) #Raw Stress unfolding
NormRawStress_unf=RawStress_unf/sum(dhat_unf^2) #Normalized raw Stress unfolding
Stress_1unf=sqrt(NormRawStress_unf) #Stress-1 Unfolding
#----------------------------------------------
#DAF and Tucker
DAF=1-NormRawStress #Dispersion Accounted For overall solution
Tucker=sqrt(1-NormRawStress) #Tucker coefficient
DAF_unf=1-NormRawStress_unf #Dispersion Accounted For overall solution unfolding
Tucker_unf=sqrt(1-NormRawStress_unf) #Tucker coefficient unfolding
VAF=cor(c(dhat_unf),c(fitd_unf))^2
#------------------------------------------------------------------------
#loop for computing Shepard index
h=0
xy=as.vector(fitd_unf)
for (j in 1:length(xy)){
h=h+sum((1* ((xy[j]-xy[setdiff(1:length(xy),j)])/(xy[j]+xy[setdiff(1:length(xy),j)]) > 0.1)))
}
ShepardDindex= 2*h/(length(xy)*(length(xy)-1)) #Shepard index
#--------------------------------------------------------------------
#Preparing De Sarbo's index
dxy=mean(xy)
dx=mean(as.dist(fitd[1:n_ind,1:n_ind]))
dy=mean(as.dist(fitd[(n_ind+1):tots,(n_ind+1):tots]))
I1=log((dx/dxy))
I2=log((dy/dxy))
I3=log((dx/dy))
DeSarboIndex=sum(c(I1^2, I2^2, I3^2)) #De Sarbo's Index
#goodness of fit measures between transformed and fitted proximities
dij=fitd_unf
trdij=dhat_unf
fitTauX=VectTauX(as.vector(dij),as.vector(trdij))
fitSpearman=cor(as.vector(dij),as.vector(trdij),method="spearman",use="pairwise")
fitKendall=cor(as.vector(dij),as.vector(trdij),method="kendall",use="pairwise")
################################################################################
##one day, for row-conditional case, these codes are ok                        #
#fitSpearman=mean(diag(cor(t(dij),t(trdij),method="spearman",use="pairwise"))) #
#fitKendall=mean(diag(cor(t(dij),t(trdij),method="kendall",use="pairwise")))   #
#fitTauX=mean(diag(Tau_X(dij,trdij)))                                          #
################################################################################
#----------------------------------------------------------------------------------------
#first resume measures
nc=c("RawStress","NormalizedRawStress","Stress-1","DAF","Tucker")
resumeall = data.frame(rbind(RawStress,NormRawStress,Stress_1,DAF,Tucker))
row.names(resumeall)=nc
colnames(resumeall)="MDS Measures"
nc_unf=c("RawStress","NormalizedRawStress","Stress-1","DAF","Tucker","VAF","Spearman",
"Kendall","TauX","Shepard","DeSarbo")
resume_unf = data.frame(rbind(RawStress_unf,NormRawStress_unf,Stress_1unf,DAF_unf,
Tucker_unf,VAF,fitSpearman,fitKendall,
fitTauX,ShepardDindex,DeSarboIndex))
row.names(resume_unf)=nc_unf
colnames(resume_unf)="Unfolding Measures"
#---------------------------------------------------------------------------------
#Recovery measures (only for unfolding)
AV_recov_pref=matrix(1,n_ind,(n_col*(n_col-1)/2))*999
AV_pearson=matrix(0,n_ind,1)
AV_Spearman=AV_pearson
AV_Kendall=AV_pearson
AV_Tau_X=AV_pearson
#dij=fitd_unf
for (j in 1:n_ind){
XX=t(X[j,])
DD=t(dij[j,])
ps=1
for (k in 1:(n_col-1)){
AV_recov= ( (sign(XX[k]-XX[setdiff(k:length(XX),k)])>=0)*2-1 ) ==  ( (sign(DD[k]-DD[setdiff(k:length(DD),k)])>=0)*2-1 )
ending=(ps-1)+length(AV_recov)
AV_recov_pref[j,ps:ending]=t(AV_recov) #averaged recovered preferences
ps=ending+1
}
#    print(j)
#    print(class(t(X[j,])))
#    print(dim(t(X[j,])))
#    print(class(t(dij[j,])))
#    print(dim(t(dij[j,])))
##poi vedrai
AV_pearson[j,1]=cor(matrix(X[j,],ncol=1),as.matrix(dij[j,])) #averaged Pearson correlation
AV_Spearman[j,1]=cor(matrix(X[j,],ncol=1),as.matrix(dij[j,]),method='spearman',use="pairwise") #averaged Spearman correlation
AV_Kendall[j,1]=cor(matrix(X[j,],ncol=1),as.matrix(dij[j,]),method='kendall',use="pairwise") #averaged Kendall tau correlation
AV_Tau_X[j,1]=Tau_X(X[j,],t(dij[j,])) #averaged Tau_X correlation
}
#
ncrecov=c("Av recovered preferences","AV Pearson correlation","AV Spearman correlation",
"AV Kendall correlation","AV Tau_X correlation")
resume_recov = data.frame(rbind(mean(AV_recov_pref),mean(AV_pearson),mean(AV_Spearman)
,mean(AV_Kendall),mean(AV_Tau_X)))
row.names(resume_recov)=ncrecov
colnames(resume_recov)="Recovery Measures"
if (printscr==TRUE){
print(resumeall)
print(resume_unf)
print(resume_recov)
}
return(list(RawStress=RawStress,NRawStress=NormRawStress,
Stress_1=mds_sol$stress, UNF_RawStress=RawStress_unf,
UNF_NRawStress=NormRawStress_unf,
UNF_Stress1=Stress_1unf, RowCoord=fitR,
ColCoord=fitC, dhat_unf=dhat_unf, dij_unf=dij,DeSarbo=DeSarboIndex,
ShepardI=ShepardDindex, Spearmanfit=fitSpearman, Kendallfit=fitKendall,
TauXfit=fitTauX, Averaged_Recov=mean(AV_recov_pref),
Averaged_Pearson=mean(AV_pearson),Averaged_Spearman=mean(AV_pearson),
Averaged_Kebdall=mean(AV_Kendall),Averaged_TauX=mean(AV_Tau_X),
Resume_ALL=resumeall,Resume_UNF=resume_unf,Resume_Rec=resume_recov,
Interactions=Delta$Interaction,mdssol=mds_sol,confdist=fitd_norm,
n_i=n_ind,n_c=n_col,tots=tots))
}
solunf <- UNFOLDING_CORR(sports)
unfplot(solunf,labs=colnames(sports))
require(ConsRankClass)
rescca=cca(sports,2,ccaiter=2)
rescca=cca(sports,2,itercca=2)
rescca2=cca(sports,2,itercca=10)
rescca3=cca(sports,3,itercca=10)
rescca4=cca(sports,4,itercca=10)
rescca5=cca(sports,5,itercca=10)
rescca5=cca(sports,5,itercca=10)
rescca6=cca(sports,6,itercca=10)
plot(c(1,2,3,4,5,6),c(1,rescca2$Uprodscca,rescca3$Uprodscca,rescca4$Uprodscca,rescca5$Uprodscca,rescca6$Uprodscca))
plot(c(1,2,3,4,5,6),c(1,rescca2$Uprodscca,rescca3$Uprodscca,rescca4$Uprodscca,rescca5$Uprodscca,rescca6$Uprodscca),"l")
rescca2
setwd("C:/Users/Antonio/Dropbox/Disco D/R projects Antonio/ConsRank/R")
